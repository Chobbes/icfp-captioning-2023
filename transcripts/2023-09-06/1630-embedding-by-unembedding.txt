                >> GABRIEL RADANNE: So let's start off since we don't have enough just simply doing things with programme, we will do programmes manipulating programmes. And we will start with Samantha talking about Embedding by Unembedding.
                >> SAMANTHA FROHLICH:   Thank you for the introduction yes I am from the University of Bristol, let's get started. So our work allows the embedding of languages with advanced semantics and binders. Let's unpack what this all means. So the embedding is a popular technique where we create language as a library within another host language. And this saves implementation effort and allows the guest language to access host language features. Binders, these are constructs that close over bind variables such as let Orlando. And they are useful for increasing express city of your language. And advanced semantics, I think I will need another slide for that one. So we haven't quite formally pin down what we mean by advanced semantics yet. That is future work. By think there is some intuition to what that is meant by the term. So that advanced semantics are ones that revolve around open expressions, in particular those are variables and binders are simple to the meeting. At this meeting cannot be encoded as normal functions semantics. For example, invertible computation. So here we have a written expression like succ x and it can either be forward or backward. So forward, you take herbal assignments to the results. And going backward you will take the results and return variables.
                 So this type of data type represents these invertible semantics. Particular for a term of results type env r and encapsulates the forward and backward directions as functions. So the forward direction takes the free variable assignments to produce a result and if succ x had this type and we go forward in my look something like this. So the backward direction takes the type of government which contains the type of free variables and the result in a uses these try work out the values of the free valuables. So we run sub X the backward like this. Now if we have the type of environment that contains a verbal that is not mentioned in the term, like this. We got know we have working out what its value is. So this is why the backward direction returns environment of May be variable assignments. Now these semantics are only interesting for open expressions. It's either the free variable that we are providing to return to a result or is the free valuables -- variables that we want to work out the value of.
                 Other examples of advancement X include incremental computation and other bidirectional domains such as lenses. In fact these two domains are where we have are two key cities. So in incremental programming, we have a embedded the cache transfer style of the incremental lambda calculus. This allows for the incremental is vision of that functional programmes. In the bidirectional programming we have embedded -- on embedded the higher order lens language. Hobbit. This is actually the first embedding of a bidirectional language with binders. We also suspect that a few other domains fall into this category. We have buzzwords years we've automatic differentiation, probabilistic programming and quantum computing.
                 So now that we know what this all means let's get into it. So if we were to add a binder such as lambda to our language, we would do this from scratch such as-- this method the binders are implement it as a keyword and are linked to their variables using indices. While this is clear in its operation and implementation, users don't really like working with indices. They much prefer to work with names. This is why people normally instead use higher order abstract syntax or HOAX, so we use the guest binder as host functions. So for example discuss binder as we highlighted in yellow and underlined it which would be implanted as the cider --higher order function. This allows guest language expressions we look written using host finders. So I've highlighted the host binders in CNN bold. So it due to its popularity, these are lows a variance HOAS of and they offer different development. But for the sake of this presentation we don't need to worry about them because they are all sharing the same key features that are of interest to us. So these two approaches are the good at different things. It has the Vantage that is really easy to use it has these lovely expressive names. But the explicit representation of the environment for De Bruijin the indices, allows operations for HOAS the cannot support. And that the heart of the issue. It isn't always sufficient for supporting linkages with advanced semantics. So for example, let's say I wanted to have free variables any guest expression. So that defining the function areas, the take a guest expression and return how many free variables that are in it. Just like this example. So they are not clear at all and how many can do this HOAS syntax. Because my guess binders have been implement it as host functions. I can's inspect them. He can imagine how you might define this function. You can imagine it would walk down the term and keeping track of how binders deep it is and counting how many indices it sees that are greater than or equal to this value. So in this case 0, not a free variable, pointing to the closest lambda but three is a free variable. Of course we have to deal with multiple occurrences of the same variable but I feel like it's quite doable in Debuijin the syntax. And is just not free verbals that is in HOAS the syntax. It also doesn't support advanced semantics. And also the reason it doesn't support advanced semantics is because it implements is guest binders as host functions. This is all well and good when the semantics align. But the issue is when they don't. And they attempt to turn and bed a guest binder with non-standard semantics as a hose function with standard semantics. For example, maybe the meaning of my free variables is whether or not they are free. Or maybe my guest binder introduces a function with the invertible semantics that you saw earlier. And our host might be Haskell. Which only has a forward or standard semantics.
                 But implementing the guest binders as host functions, we are limiting ourselves to what host functions are capable of. So in this example, that is what Haskell function are capable of. And the Haskell functions know how to do is take a value and subdue the variables. I wanted to do succ x the variable example and I have to close over it with a host function and then all I can do with that provide the values of the free variables with and get results. And this works fine for the forward direction. But kind of leave me hanging in the backward directions. Likewise, Haskell doesn't support incremental functions. So I would need to be able to embed in incremental language via HOAS. If the host language doesn't support it, I cannot embedded via HOAS. I know what you are thinking, I'm a really good Haskell programmer and it has always cool features, I bet there is a way of doing. Sadly, that is not the case. Even if you are an expert in the field of bidirectional programming you have got a ICFP per and is Journal extension and it's all about coding to functions at once using the lambda and that sounds promising. Unfortunately, this  does not help. Because HOAS of we cannot access the free variables. And so actually we do need the indices. But that is not what we want either. We want the best of both worlds. We want a way of doing it, it has a usable names and is easy like HOAS  and also as a power DeBruijin of style and just order representation. Likely the literature has just the thing and that's Keeton's embedding technique. So at Lindley providing implementation of an isomorphism between HOAS and De Bruijn. You can see it has this lovely lambda X dot X in it. And so we would use the isomorphism to convert that to the DB. Just like be-- we go to the first order setting, perform the dead code elimination and then take the other side of the isomorphism to give back what they want. The lovely HOAS term just as they want. This is perfect. We have our HOAS interface and to de Bruijn control over the verbals. Sort embedding by embedding framework bills upon at keys work. The provide a way of embedding linkages and advanced processes. So is a link which implement or cut you just need to follow the simple four step recipe do this. So I'm going to show you the recipe and then we will run through it step by step with an example. So Step 1, you need to invite if-- I identify your semantic domain. The invertible or incremental programming or something else. You need to identify it and make it concrete is data type in your host language. Step number two, now you need to define how the constructs of your language is going to behave in the semantics. Step 3, provide your HOAS syntax so our framework uses HOAS as the front end and it's going to use the embedding to connect it to your syntax so you can just provide it as normal. So far we got syntax and semantics. And that's left to do is combine them together. And that is step number four. Which provides lifting functions that are going to automatic they connect your HOAS syntax and then semantics. And let's see it in action. For simplicity, we are going to do the simply typed lambda calculus with a standard or the forward semantics that I showed you earlier. So Step 1, I don't fight your semantic domain our example domain that is forward direction in our invertible programming example which is going to take variable assignments to results. So this step is all about making the concrete as a data type in your hosting was. Sort semantic type will be this. It contains a function from free variable assignments to results. In the free variable estimates are in a valuable environment. And this value environment is built upon an environment type provided by our framework. Because that seems the language of will mentor making their own. We provide a bunch of functions that helps the manager the environment. So essentially, in this step, we are seeing what it means in your semantics for a term of type result R under environment M and what the semantic should be. Step number two, you define how each of your constructs in it is going to behave in the semantics. So for example, simply typed lambda calculus. And we got only two. We got lambda and we got that. To define their semantics. We write a semantic function over the semantic functions is probably pretty familiar. So take a semantic term which has letter A and its environment and it can use that to make letter B and letter L abstract over that to produce a function into your semantics. So you might recognise this as a standard introduction rule. And the type of app is very similar and now this step, of course for the simply typed lambda calculus in his normal semantics is not very interesting going on. So let's take a slight detour to see something more interesting. So let's take succ X example from earlier and it's full invertible semantics that we can achieve the behaviour that I told you earlier. So from a users perspective that writing the function is pretty straight forward. The semantics of SOP is going to take if term which represents x and we need to make a term that Ruben sense succ x so in other words we forward and backward functions like has those work on X and we need to make them work on succ x and so the backward direction does the opposite. It has a function that knows how to deal with acts. So we take the result and Eucharist that by one and existing function use. And if we run the whole recipe on this, we get the desired here that we want to. And we noticed that we are using this run open function. And is provided by our framework. That uses unembedded to have the whole syntax so extracts the semantic type from HOAS the and also see the environment action here. We really can have advanced semantics attached. So let's return to the simply lambda calculus and see the rest of the recipe. So far with the first two steps you can think of yourself as having created a shallowly embedded language of your version with an explicit environment giving you full expressivity of the Debuijn the style in support of remark freeing you from having to make a full first-order representation making sure that you can still connect to HOAS the front and. So leaden step for three is providing your HOAS syntax. So like I said we are going to embed and to connect to the syntax the semantics that made the syntax that you can just make this is normal. So from the front and I chose in the type list final variant of HOAS. And so there is where we defined syntax is a type class and each construct as a method of that type class. I chosen this in particular because that's extensible in both syntax and semantics. And embedding by unembedding preserves those benefits. So for example I could add a new construct by just adding a new method. Or I can have a new type class with all our methods and it. And because we kept expert abstract we have multiple interrelations of these type class. And embedding and bite unembedding preserves all of these wonderful benefits. And so at this point we've got the semantic backend which take takes the behaviour of her language in our desire domain and we got our lovely friendly user friendly interface. And now we need to connect via embedding. So the step is supported by our framework. Winning the all the info mentor has to do is make the semantic type and instance of the syntactic class. They do this by wrapping the semantic type and by a type of backer and choose the appropriate lifting functions fixed we provide elite family lifting functions to make this connection quite smooth. So the first order of the first FO lifting functions are the constructs like app that do not bind variables.
                 Because the only has two arguments, we are using FO to in this case. And the second order, or SO lifting function. That is the binding constructs like lambda. This takes an extra argument in each of lambda's arguments. Because each themselves can have arguments. So connecting these events semantics this whole HOAS syntax is what is made possible by her former. A specially by the MVI wrapper type and the lifting functions. Some more details on that in a minute. As well, we are successfully embedding our language. So now this process is little bit more involved, then just embedding in normal language. We have tried to make these steps, things that you will be doing anyway. And provided as much support as possible in the framework. So our goal was to minimize the extra effort, and with a worthwhile price to pay for the ability to embed languages with advanced semantics and binders. We have put some constraints via the semantic type and I'm sure that you all want to know how the and via type wrapper and lifting functions work. So let's take a look at those now.
                 So in order for us to manage the averments for the language designer and to perform the unembedding, we ask the semantic type supports two things. The ability to do this for this instance. So what VA are is doing is unpacking the first element of the infirm and what is we can is doing is taking the bigger environment just ignoring the first parameter and using the rest of the averment. So you might be wondering why we are only focusing on weakening and the other manipulations like exchange or contraction. That's because unembedding the technique only uses weakening and we did not want to burden the language designer with things that we don't need. So we do want to make it as simple as possible. So earlier, to achieve the connection, between HOAS the and syntax and desired semantics, we use the MV type wrapper and the lifting functions. Envi is short for abstract over the environment type parameter of the advanced semantics so it can be the instance of HOAS. The this is done by the indexing of semantic type IN environment. Know that this is the slight generalization of what they are actually already doing in the unembedding paper. Now lifting functions, they are not quite as magical as they seem. All the are doing is doing the tedious management of the environments for the language implemented.
                 So I will not show you how they are defined because we defined them a little bit magical to make them super useful. But they do follow. A somewhere pattern. So in the first-order case, all you are doing is with the environment is passing it on. There's nothing to interesting happening. The only thing that affects how this function is defined is how many argument the construct has. So that is why we've got lift FO functions to avoid this routine. The second order case is a little bit more involved. Because we've got some binders. We need to do some reindexing. I will leave that definition for the paper. The key point is that all it is doing is it is just doing this tedious management of environments. So over all, or from works just ensuring that the language implementation get the best of both worlds. S was making sure they can be matched up with the variables type class and adducing the burden of the first-order representation providing blocker functions and lifting functions. As I mentioned earlier, our paper features to substantial case studies of using this framework. So we on embed the CTS variant of the incremental lambda calculus and we on embed the bidirectional lens language hobbit. So let's take a look at them and before we go quick warning, these are full-blown case studies with advanced Symantec s. I just want to give you a glance of what we have done. Don't worry if you don't follow all the details were by want them to be up there in case you are interested in these domains. So RT -- CTS case study is all about incremental compete a should. That's about speeding up mutation. For example, if I have summed up the list and then subsequently one element of that list was incremented by one. And makes no sense at all to resend the list. It is much better just to add one to our initial some.
                 And so the CTS semantics that we had, were split into two parts. So the first part and it uses that to produce an initial output alongside the cache from the environment of initial inputs. And the second part the translator takes an environment of how those inputs have changed and the cache and it changes until you should update your new cache. So the nice thing about the semantic type is it is pretty much taken straight from the paper. We reran a extremity from the CTS paper to make sure that was the case. The conclusion was that unembedding does have some overheads and it does make it slower than the re computation but those can be optimized away and we did that using template Haskell.
                 So or other case study, the high order lens leg which hobbit. It is all about lenses and lenses are a way of interfacing with a big structure. So you can either extract a smaller view V with a bigger structure S using get her you can update your bigger torture with regards to an updated view. So the semantic we chose for hobbit realizes the idea of an open expression of the lens. So takes the type environment of the types of the for three variables -- free verbals and then has a lens between the results types and the free variable assignments. And then we asked a few the embedding by unembedding recipe on this. We get the first embedding of bidirectional language with binders. And in this case, the binders are particular interesting because they allow for bidirectional case analysis. So please look at the paper for more details on that.
                 But this is not the end of the story. Is a mentioned earlier, there are more domains that we want to apply this technique to. And also like to try a linear setting. This allows the --on embedded sparkle. It language for particularly invertible competition. We are also interested in the category will semantics of what images this could be applied to. We suspect the idea of unembedding is to interpret the HOAS the terms as a precept where letter C is a semantic domain and I'd love to chat with you in the break if you are interested in any of these directions. So embedding it by unembedding is a framework for embedding languages with advanced Symantec some binders. It over comes the limitations HOAS of by building upon it Keaton's unembedding. This is joint work, collaborators, we be happy to chat with you about the further. I will now take your questions. Thank you for listening. 
                >> GABRIEL RADANNE: We have questions? 
>> I have a question. Oh, go on. 
>> Hello I am Christian from QB logic. So when you showed the rules you showed weakening. And I was like my linear logic is not that good. But thought that weakening is one of those rules but is not allowed in some structural typing discipline like linear. Right.
                >> SAMANTHA FROHLICH:   We hope that we can get something worked out, it is really quite fiddly. 
>>  Such as the switch else, weakening by exchange or?
                >> SAMANTHA FROHLICH:   So think what it is is you only need weakening if it is a nonlinear setting. Still you might not need it if it's-- the results back, I don't know I'm exploring at the moment. 
>> Okay thanks. 
>>  I have a small question. So what, two questions actually. The first one is what kind of complex binders could you support? And what I'm getting at is things that are supported by auto steps, it is a cool library that supports -- that are more, gated like Pearl old binders or several kinds of environment and these kind of things. So have you look at these kind of things?
                >> SAMANTHA FROHLICH:   So far we have not, we have the let the can do sharing and we have the sort of bidirectional case analysis side. And part of the future work I'm currently looking at doing more exciting ones. 
>> Okay. 
>> Think for the topic I'm interested in how is this library compared to other binding techniques such as locally nameless? Where you have named representations for free variables but you have to buy indices for bound variables. Like what, so is there like any connection between the two? Or any trade-off?
                >> SAMANTHA FROHLICH:   Ah, I think we look at that once. So I'm not sure. I could have a look. 
>> Okay thank you. 
>> Another question [Laughter] what do you need in your host language for your framework? And in particular, like if I wanted to, so what exact lead do you need? I see the universal quantification.
                >> SAMANTHA FROHLICH:   Yes, um, just need someone to go and implement it. [Laughter] 
>> [Laughter] okay.
                >> SAMANTHA FROHLICH:  Mmm. You might not find someone to them moment that. [Laughter] 
                >> GABRIEL RADANNE: Okay thanks to the speaker again.
                
                >> GABRIEL RADANNE: So our final -- our next presentation we will have the final mix of staging and module system in OCaml. Presenting and we will wait two minutes and then get going. 
>> Hello, hello? Okay.

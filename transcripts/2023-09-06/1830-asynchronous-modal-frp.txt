                >>AMOS ROBINSON: Okay thank you Patrick. Now we are with Patrick again. [Laughter]. So Patrick is extending the Rattus with Asynchronous Modal FRP. 
                >> PATRICK BAHR: Right so what we want to do here is Functional Reactive Programming using model types. What we want to build a asynchronous systems with it. So what I showed you earlier on the first talk, it was actually asynchronous language. So how do we do that?
                 So let me back up a couple of steps. And talk about what is actually a reactive programme? So a reactive programme you can think of this box here and this will receive at the top, a receive some inputs. Right. And they continuously sort of drop into our programme. Right. And then our reactive programme has to process these rather than it sort of ghosted the state of flow graph and then the inputs will be processed and then they follow as the outputs continuously at the bottom. This is how you can think about the reactive programme. So for example, Gui work like this. So you have some input from the user. And has some inputs from the text fields and gives into our GUI programme and the top here and then gets processed and then the programme reacts in some fashion by providing feedback to the user by providing UI something like this. And also an example of the reactive programme like this. A robot. How does it work? It has to continuously receive input from sensors. These get processed at some fashion. And then where you want the robots to respond to the sensors in a useful way. So the outputs here are some commands to the actuators to actually move the robot in some fashion.
                 This is how I at least think about it, and reactive programming.
                 So the signals, are at the heart of this view of reactive programmes. So each of these nodes, you can think of a signal, these signals are time varying values. Because you constantly have input coming in from the top and these will then change the value of each of these notes and so you have these signals that come in. And now to just show you an example of how you would actually right a programme, a programme that looks basically like the data graph. I just name the inputs XYZ and the outputs later a B. And this example would be reactive programme in the sort of visualization. So we have here, A is defined as the zip width of + and X why. So we simply + the two input with your X and Y together with the point wise. And then we apply the function to check whether the integers here are actually the positive. So this is how we would implement such a dataflow graphic this is very stepping. --static. So this data flow graph will not change. And general, we want to have programmes where you dynamically update these dependencies.
                 So you might have first in the programming when it runs, this dependency. And something might change. So some part of your GUI might be deactivated and so they are not influenced the output anymore. So we might go away and they might instead influence other parts of your programme. So these dependencies might change our new input comes in. So are language needs new -- we need to support something like this picks kind of dynamic updates. Another question is that how these signals were boxes in the graph that I showed you how are these design --defined exactly right and as I talked about my first talk. If we are not careful we are prone to writing programmes that are not good. Either not causal or leaking memory. And so one solution is to modifiers. To use modifiers. To capture the passage of time. So that we use the modifier of type circle eight. To say something like we have data of time A and available in the next time step. And then we can have had in the previous talk we have signals indefinable using this conductive definition. Which expresses this idea of I have data, the value of the signal now is of type letter E and on the time passes and then we get the next value of the signal and so on and so on. So the signal might be like this. The signal of integers. It starts with a value one and then the time passes and then numeral two and then time passes and the number three and so on. But crucially we need a way of finding out that time has passed. This seems to assume that we have access to some global clock we can say well, can we now going to the next timestamp and update the signals on Mike's we need some kind of clock tells us when the time has passed. And this might be appropriate for certain applications like the robot examples or simulations where you have a clock that defines the sampling rate of the signals. That you are dealing with. It might not be appropriate for other applications like GUI that is not asynchronous and doesn't have access to the global clock. So this talk is the new Modal FRP language if you call it as an grad, this allows this kind of programming this kind of asynchronous programming. And do this and it uses the introducing of new model type of existing later, sort of the a combination of the circle modality that I showed you earlier and X essential type. And I show you the operational properties and no space leaks and product to be for this language. And first asynchronous FRP language for which the first of these operational guarantees have been happening. Improved. All right let me show you this language around asyncrat. The and let me backtrack a little bit and start from the old modality, the circle modality, this is how we would define signals using that modality. We have the value now and then later we have the state of the signal in the next time step. So the signals might look at this again. We have the value now and then the clock ticks and we have the next wilting and so on and so on. This is the synchronized version of the signals we have a global clock which is very convenient and it makes the programming very easy and everything is nice and civilized but it makes it more restrictive. A different way got sort of losing the restriction bit is to say well each signal can have its own clock or some clock theatre. And so now we have a signal over the clock fadeout and it consist over the value now and whenever this clock fadeout will tick then we have this next date of the signal. So we have is modality annotated with the clock. Tells us when it will tick. And now the stream signals might look like this again the different values are separated by the ticks the of a clock here b it is a local clock,y ticks of a clock this theta here and so different signals might have different clocks. And is only small also it still static and in the sense that each signal has a fixed clock when it cannot change. And also means that the kind of dynamic switching of the signals, the dataflow graph that showed you in the beginning where we sort of moved the arrows, it is not possible because it might require that we are signal that we define, it depends on the different signal and it has a different clock and must be able to change the clock dynamically. In order to allow the kind of dynamic switching of signals.
                 So what we instead propose is this approach. That uses X essential want to vacation. Now the single of type A again a value of type A. And also, some clock theatre. When this clock theta ticks we get the new state of the signal. So it consists of two components, so the actual clock and about his the actual clock. And the second component is the actual delayed computation. So the signal will tell us is the clock for the next you value each step of the signal? So what does that mean? It means that the signal now means something like this. And there is some clock that theatre will one ticks and endeavor clocks t theta ticks and so on and so on so these might change over time. These clocks are associate with this. The signal, the dynamic switching of both the actual clocks with the stream. And allows them to also switch dynamically between different signals. This kind of dynamic humour that I showed you earlier in the state of the programme. So that is one that we are going with. This we abbreviate to this circle E notation.
                 Okay this is the idea of how the circle exist totality. How do we programme this? Again I will go back to the old circle a modality to see how this works. Again this is the old definition of our signal that is the old modality. And I assume the inference with the things operator to construct the signals. Rate were with a head of the signal and in the tale of the signal, and this is our increments function and I've seen earlier, in the previous talk, where we take input will and increment. Like we do so by again, we put a match on it. We get the head of the signal. And the tail of the signal and use this delay in advance to interact with the leader modality. So this is the typing rules for the delay in advance. So here we delay the computation. By taking the computation and requiring it to type check in this extended context. Where we insert stick and it is now tea has access to this information that has time has ticked. And it is evidence that time has ticked and it can use that tool to call advance. We can use this turn term later in something of type letter a into type letter A. And this is exactly what it does over here and turn our variable of type later Sadie event. So this is the old modality.
                 So how this works with the new modality. So things will change a bit. So the type of rules will change. And now the delay here, not also takes as an argument for clock. So we want to say we want to delay this T. We want to say that we want to delay with the specific clock, theatre. And also the ticks in the context. They are annotated with the clock, theatre. Now T is access to the evidence that the time has ticked on this particular clock theta. And we can use that when using advanced. The type of rule for advanced looks like this. So it can advance the delayed value like this. But only if it has a to can the context happens to be of the same clock as the clock of the delayed value. Remember, this latent modality is really an extension type and so it has two components. A clock and this one here and the clock of letter E and the actual delayed, mutation. And we don't have access to via the advance. Yeah so we have advanced and get the second component. Get the actual value letter eight out of this. Yes we can use this for our increment function here. And we say, okay we want to advance xs and we delay according to the clock x of and this type of checks now. Is trying the existing like a deli. And in this graph, it is a type check in the new language. Here's an example something that doesn't type check anymore. So for good reasons, this again is using the old modality. It takes into delayed integers. And produces a new integer by delayed integer by adding the to do that. And this works essentially because we know that the global clock, this means that you delayed integers will arrive at the same time. It is nice and well but this doesn't work of course in a asynchronous setting. So the two integers might not arrive at the same time. So indeed this does not type check anymore. We cannot find a clock according to which we can delay so that we can both advance X and on Y. This is not type check anymore. For good reason.
                 So this is the leader modality. There is one extra until to it because it might still want to able to synchronize delayed capitation. And there's an extra example where we might want to be able to sing when I was delayed capitation. And there's an example where we might want to use that. And that's the zip, takes the two signals of type letter a and if I be and there is a new signal that contains both A and B. So this type checks in using old modality. Because every thing is nice and sickness. Because it doesn't work anymore for the asynchronous calculus because now the tale of the signals might arrive at different times. So the advance here, don't type check, don't find a clock. So that we can delay and that we can both advance on both of these. That doesn't work. So instead the language has a primitive code select. What basically gives us a way of observing which of these two will arrive first?
                 All right it has three different outcomes depending on which of the two will come first. Or maybe both. This is the general typing will for the select. It takes to delayed competitions. A U and a V, and what it does is checks which one of them comes first. You get this output here and a some type here and then you get the first one if the left one comes first and then you get this one here and the red one comes first and otherwise we get this one if they both same time. And we have these three different outcomes, let's see, I forgot to mention is. Importantly, so the time was similar to advance. But now we have to have an appropriate tick in the context. Them lite, going to this clock here. Which is the union of the clock of U and of Clock B. The now we can take the union of the clock now. What is me to take the union of the clock to make the union of the clock will take whenever either of the two will take. So this will produce a value whenever either U or B ticks or with of the same time. So this was happening. So if we get the delayed here according to this union clock xs and ys of and we will have this type check. Just to look at one. Example, if you look at the types here, the types of the tales of these signals, the delayed signals. And then use them over here in the select, what happens is that the first case where we get out is a non delayed signal. Actually signal of a. This single has right now but not this one here. And still later single B. And what we do is we recursively calls it. And we with the new value for signal, and we still copy over the value of the old signal. On the second signal. All right so this is how the synchronization works. And we can implement something like a zip with this. Okay. So one thing I still want to mention is dynamic switching. Which I mentioned earlier. So we can change the topology of our dataflow graphic so the switch company to which we can implement in the asynchronous graphic it takes two arguments, so the two signals, so this is the signal here and then the delayed signals. And the semantics of this is it produces a new signal that first behaves like the first argument. And then as soon as the second signal here that we get the second argument it arrives and it will switch to that behaviour. And as soon as a second one arrives we switch to that. Here is an example that shows what I mean by that. And so we apply this which to two signals. And the first one produces even numbers. 034 and so on. Each separated by a check on the clock theta one and the second one produces hot numbers separated by a tick on a different clock. Like this. And then the possible signal that might come out of this might look like this. It produces some even numbers. According to the first signal and again at some point, theta to will tick and so we take over from this second signal. And we now produce only on numbers. And we switch off the behaviors from one signal to the other. Enabled by the use of. Okay so I talked about clocks, they seem to be kind of important for the through work. The question is where do they come from? So they come from input channel. This is the picture of our reactor programme. That we received some inputs from input channels. Me call these input channels Kappa one and cap two and so on. And the clock sets of input channels. And the inputs here this clock will take whenever any of the channels that are in them will increase in value. And this clock will take whenever we get a value or a new input from the channel or the channel over there. And you can see the idea is that whenever a clock ticks we need to update. So we need to update whenever one of the dependent inputs, the inputs that we depend on receives a new value. That is the idea behind this, these clocks. And how are these actually computed? If we just unfold the definition of signals. So this was a signal of flows. It consists of actual current value of the signal. And then also the delayed next day of the signal. Which in turn, again this late modality here. Is the XML types and also consist of the clock. With the clock it says, when does the signal update? And this is where the clock is actually computed. So the signal, the definition of the signal will itself compute one of the clocks for the next time step. So when we run a problem like this and this graph and this change and say this dependency might disappear. And the clock down here will be updated. The programme will itself update the clock so that now the clock is like this ticks only contains Kappa one. Is it doesn't depend anymore on this. And so let's look at this space leaks.
                 So I showed you this definition of zip. This actually doesn't type check, so I snapped, I snuck this past you. This doesn't type check. Actually what happens here is so I said to you that we remove this old value of Y here. We move this over into the future if the signal has not ticked yet, right only if the first signal is ticked and sort of keep the old letter Y around. And of course this is work in general because we should not be allowed to just move is kind of things across time. Across the ticks. And so this one doesn't actually time check. --type check. And the problem is that we removed this verbal over a particular that is introduced by this delay. So does not type check. And unless Y is of the stable type. And the problem is that in this case the X here is another example, the X here is all the way over here and there is a tick. We use it over here and is not in the scope and more. And the fix here is to make sure that the types letter A and letter B are actually stable. And this makes sense to require this. And it has to buffer the signals if it hasn't arrived yet. The other signal arrived so that it makes sense that we require the types are actually stable. So can buffer them. So that is the idea of the stable types. So that brings me to the end.
                 So in summary, I shown you the new language, asynchronous that allows you to programme in a modal language. To build asynchronous systems. And so it works using this new type modality that combines an existential type to keep track of these clocks dynamically. That's what computes both values. And that is all I had, thank you. Thank you. 
                >>AMOS ROBINSON: Please come to the microphone and try to introduce yourself.
                >> AUDIENCE:   I am Sarah Frydman. So you can write like filter on a signal in the language right? 
                >> PATRICK BAHR:
                >> AUDIENCE:   Yes indeed, yes. And you can't have a signal that fires any slower than any given input stream? 
                >> PATRICK BAHR: Yes that is a kind of filtering yes indeed.
                >> AUDIENCE:   Okay that is interesting. 
                >> PATRICK BAHR: Yes it is interesting but that is something that can be used solved but we haven't yet. So the ideas that you want to sort of introduce other clocks. Synthetic clocks for the filter function. With the filter function does is it gives a predicate that says well whether some inputs should be passed through to the output. And so we can use that predicate to build the synthetic clock. So the space on another clock. So you filter that, some clock this predicate. And so imagine that you can extend the system like this with these kind of synthetic clocks defined by these predicates.
                >> AUDIENCE:   Okay.
                >> AUDIENCE:   Hi, Gershom Arista networks. So the clocks that you have here it is different but similar to a lot of stuff regarded in Kirchen and I wonder how these clock types with the X essential relate to the sort of the clock types in the McKnight at key style? Traditional because some things feel very similar but I'm sure they are not the same. 
                >> PATRICK BAHR: Rate, so these clocks are different. The clocks in Gardrecursion, they are used to essentially recover: Doctor types. To say I have this -- recursive definition but that means if I have a -- recursive definition even only to find things that are causal. Which we make use of. They can't sort of discard and make them in modality. But if you actually want to define connective types, you need these clocks to be able to remove these guarded nests in a well-formed manner. Like in a safe manner. And that's how the clocks or use their. So the other clocks are here really to track dependencies rally. You track the dependency of some output. So you basically have some bookkeeping that says okay this book, this output depends on this and this channel. So whenever I receive input on any of these channels I know that after recompute this one. So there is quite different goal we want to achieve. Just we use overlapping terms.
                >> AUDIENCE:   Mary Shamin from Chalmers. Do have a --app? 
                >> PATRICK BAHR: Not yet. [Laughter] one thing we want to do with this in the end is like GUI is very asynchronous and that is not set up yet for providing this could've things. And that sort of where we are working towards. GUIS but with you have the problem that you have this kind of static set up and you have a bunch of input channels and some output channels. And creates the new input channels and that something we want to work towards.
                >> AUDIENCE:   Hello Alex hear from -- that was actually going to probably be my question two, if you can't have a signal whose value is a signal, you possibly have time sensitive dependencies? 
                >> PATRICK BAHR: Sorry you can have signals of signals.
                >> AUDIENCE:   Sorry in previous talk you said you dealt with Chris-- leg. 
                >> PATRICK BAHR: It depends on how you want to define it, there is other ways of defining this if you have the stream. So we can talk off-line. There is ways of defining something of type, stream of integers but in a safe way. Not just at replicating sort of some inputs strings.
                >> AUDIENCE:   How does it tie into the a sinks and sources were as input coming from? Because the definition is pure, the whole running is very monadic and very side effects. Full I would say. 
                >> PATRICK BAHR: We don't know yet, I mean the short answer we don't know yet. This is just pure calculus. There is no implementation you. We are working on. That we could build this into an existing like Haskell the same way that you have the previous system that I showed that you can then put into output that is created by some I/O read from a file or read from some kind of sensor and then produce outputs into the I/O. And you can put them into a system and it reads output. 
                >>AMOS ROBINSON: Okay thank you Patrick. 
>> [Event Concluded] 
                >>AMOS ROBINSON: Until.
                [  Sneeze] . 
                >>AMOS ROBINSON: You have a break for 30 minutes.

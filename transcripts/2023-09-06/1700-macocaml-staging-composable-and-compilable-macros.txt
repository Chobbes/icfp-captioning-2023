                >> GABRIEL RADANNE: Okay let's start, please take it away.
                >> NINGNING:   Okay so hello everyone! I am Ningning Xie, today I will talk about MacoCaml: Staging Composable and Compilable Macros. We use macros to compile-time bindings. Which are different from macros and linkages no racket. As I will expand. And this is work with Oliver, Leo and Jeremy. And we want to calculate X to the power of letter N. And the definition is simple. If N is 0 we return one and either recursive case, the power just cause itself with N -1. One we call power with different inputs like power 5, two, between undersea 32. However, calling power this way can be costly, is execution power 52 we are around power five times and each time we need to check whether the input argument is letter N is 0 or not. On the other hand, if we know statistically that the power is going to be code with the first element being five, we can define you specialized version of power which directly returns X to the power of five. In the power of five 2 will return you to the same result. However while we get efficiency, through the definition, we lose abstraction and we are needed to define any specialized diversion of our. So the question is, can we get the best of buzzwords? And in this talk, I'm going to introduce the MacoCaml with three key contributions. The design and phases. Two techniques that are often considered separate. And as we will see, our design also works well with other language features such as module system in your Mack O camel. And you second we provide you theoretical foundation for MacoCaml for formalizing you feature-rich macro calculus with important practise like stillness and fist distinguishing. And the implementation you working implementation for OCaml. And finally provide you implantation for MacoCaml for you OCaml compiler and implantation is available as an artifact and later we will show some examples where you can be using MacoCaml.
                 The rest of the talk I will give you an overview of MacoCaml, by briefly going through these three contributions.
                 First you unifying framework for staging and phases. Recall our motivation where we would like to keep the definition of power abstract and at the same time get the programme to run efficiently. One approach to achieve our goal is staging. Which is where established technique to generate efficient code with predictable performance. Essentially, were no formal programmes take some input and further some input, staging divides you compilation into multiple stages. And each stage the compiler is given some input specific to that stage. And is partially available evaluated according to the input to generate efficient code for the next stage. In our particular example of power, we would like N to be provided in you stage before X. So that we can use the same abstract definition of power to get more efficiency for any specific N. And to do that we need to express annotations. Quotation and slice. Essentially quotation is the presentation of the expression as programme fragment in the future stage. So if E is int,  then he has tab in the expert were expert means programme fragment any future stage. We also need you splice. Which extracts the expression from this repentant and its representation. If letter E has packed into expert, then the splice of letter E has tightened. And we can apply staging into our power example. The slide shows how we can write power as you macro in MacoCaml and I will explain what macro means later. And you observe the definition is very semi-to before. Except that change of the some type from inc the and the some type expert and I inserted the staging quotations here in there make things work. Or concretely, where in letter and is 0 instead of one. And the programme will return the quotation of one. And in the recursive case, we are going to build you case where we are going to build you large quotation and within which we are going to splice into expert to Inc. To do this multiple location. And then now we can define you specialized version of power by doing this. So the definition power five simply you cost power with you static five and the quotation of X. And then the splice, that splits the whole function application. Which will then eliminate the abstract overhead by power generation the function body like this. Were all that recursive cost to power have been on road and in-line. And now the code to the power five 2 will give you 32 as expected before. And now what we observe from this example? First got you notice that we have two different kind of funding. We have power as you macro and then we have power 5 at you like definition. And also power five uses power inside you top-level splice. And top level I mean splice is not within any quotations. And then moreover we expect of this power five is generated at compile-time. So that later power five 2 can run efficiently at the wrong time. And this example demonstrates the first key design you versus an. And that is, we divide evaluation into two phases, compile-time and runtime. And the am cross compound the bindings in the left definitions around the bindings. And we you staging annotations to cross our phases. So you macro can co like you random variables and that can splice macros. And the next question is when does the computation happen? Like in this case, like with the power five to generate the body of power at this power five definition at compile-time. And the answer is compile-time evaluation happens inside top-level splices. But in this case, the power five splice, this power inside the top-level splice which will trigger compile-time evaluation by evaluating this expression inside of the splice. And that extracts the evaluation results back into the programme.
                And is another example today mistreat this point we can also define you macro that can simply because power. And this definition as well typed, but no cogeneration happen because we don't have any top-level splice in this example. In our design it also works other language features and OCaml. So is supposed to that we put all the definitions power and power five inside you single module. Now we have two ways to input this module. The runtime import compared to compile-time import. For the runtime import the definitions around the imported module at this evaluation phase as they are before. So the power will remain at the compile-time and the power five will remain runtime. And for the compile-time import, the evaluation phase will get shifted. So the power five that was originally runtime it becomes compile-time. And the power which was originally compile-time it cannot be spliced at compile-time. And I will make this more precise later.
                 So putting all that is nice together. We have seen that we have two different kinds of findings. The findings that are let - at the runtime and macros and data compiled time and we use staging annotations to curse validation phases. And we can also import modules. And for the runtime input, because of the definitions remaining at the same evaluation phase as they were before. You let's definition in the current module can also splice an important macro and you macro in the current module can cut the imported lead. And the compile-time import, because of the valuation basis get shifted, the left definition and the current module can splice the important lead and you macro in the current module can slice the important macro. And later I will show you how we manage all those leaderships formulas through it and so you don't have to memorize all those relationships. And this summarizes the first part of the talk.
                 And the second part of the talk I will show you how our design is formalized as you macro calculators --calculus with important practise like distinction. And our macro calculus is Mack O camel. It supports all the features that we have seen already staging phases and module inputs. And moreover, MacoCaml on top of OCaml forces us to confront several practical to issues such as interleaving the typing and comparison evaluation as well as the references with explicit compile-time heaps. And in this part of the talk, I will briefly review the key aspects of the categories.
                 First we have mentioned that we have two evaluations, this is runtime and the compile-time. And this formally we manage the definitions using the notion of you little. Which is essentially an integer number. And intuitively, you level tells you which evaluation phase an extension is an. So for the expressions at Level 0, the runtime, for the expressions of negative levels, the art at compare time. And for this definition you MacoCaml also features leveled bindings. Select definitions, they are bindings of the Level 0. And at the macros they are bindings at the level -1. And for the module inputs. You runtime input will keep all the levels of the important definitions and the compile-time input will shift the level of important definitions that -1. And on the module affect compile-time we are also evaluated at the compile-time in order to initiate all the references. And of course the more doing that you input you can import other modules so in the end you will get you tour of modules. And in our importing rule will take care of that and the design is largely inspired by the module system and brackets as described in this --2002 paper. And the staging annotations, essentially you quotation increase the level of expression inside the quotation. And the splice decrease the level of expression inside the splice. And our type system and forces the level research and that says that each variable is used only at the level it is. So this way we can make sure that the runtime binding can only be used at runtime and compared bindings can only be used to compile-time. And the accounts for the compile-time evaluation we need you special rule of slides. For the top-level slices.
                 So there is one rule in our type system that says okay, if the splice is at the top-level slice, then I will evaluate this expression and until it becomes the quotation and then I can extract the capitation result from the quotation as the tap checking result of the exception. And here's the expression in blue denotes the compiled form of extortion. In this case, it is really just you subset of the self-expression and but without top-level splices. And once we have references, this compact form can only contain locations. The interleaving typing and the compared time evaluation this way. Allows us to formally reason about the compile-time competitions. But also processes challenges to the top safety results. You specially when we have references.
                 OCaml has support for references. So here we can define ID as the Invigor reference initiated with value of 0 and then we define the function Inc. That will increment this reference and then return the content inside this reference. And with all the macros and compile-time input things that we have just described, maybe we also want to define you macro version of this inc.
                 And what we can do is input this module graph at compile-time. So the idea becomes you what the compile-time binding. And then define you macro letter M Inc and then one code will increment the ID and then made try to return the quotation of the value stored in this ID.
                 Now consider what would happen if we try to splice this M Inc. Acro. Because ID we try to input ID from compile-time, we will leave you late the module rough. So ID, we are eventually some location in the compile-time peak. And if we slice this M in this way that will expand affect compile-time to you programme that refers to you location in the compile-time he. And then run in this programme will give you an error. Because the compile-time heap may no longer be available at runtime. And this breaks our programme- my property that we want will type programme to generate well type target programme. But unfortunately, in this case we can reject the definition of letter M Inc., because ID is not well staged. Why?
                 Because the ID is the definition that we import at compile-time so it is of able at level -1. But they are using the ID inside the quotation which is our Level 0. So they are not using their ID at the red level at which it is bound. So we won't be able to splice this letter M Inc definition in the first place. So we are lucky in this case. But generally, how can we make sure that you compile-time capitation will not depend on you location for our compile-time peak. And to do that our macro calculus also features you reference for this and compile-time heaps so that we can formally reason about practise of the type system and we show formally that we compile-time keep --keep can be decided after completion. And before we show you results of our type system. I want to briefly go through the type of judgment of our system that give you some intuition of how our type system works. So this is the judgment for our typing expressions in our system. Which says that other under compile-time signal one and the macro definitions and Omega, the type X context demo, the expression E at Level 0 under some compiler heap has-- compiles to this expression and updates the compare time he. To Sigma two, so yes you need to memorize nine components of this typed of judgment. And this compound mode your is just used to edify the top levels splices and trigger compile-time evaluation.
                 We have all the detail about the typing in the paper. So I will not go any deeper than this. And with this type system we can prove formally that our type system is found in the sense that we are typing the source programmes. We are talking the target programme. And it is well typed under an empty he. So make sure that the compiler capitation cannot depend on the run type heat. And which prove the phase distinction which says that the compile -- compile-time capitation such as macros as well as compare-- compile-time module inputs can be all erased before random evaluation. Okay this summarizes the second part of the talk. So far we have seen that the design of MacoCaml provides you framework for staging and phases and also formalize the key aspects of our system as you feature-rich MacoCaml  calculus.
                 And the last part of the talk I will briefly describe our implementation into one larger example. So the calculus macro we have seen captures the essence of our design. And guided by this formalism we have an corporative our design into our OCaml compiler and this compiler is available at the artifact. So you are very welcome to try our limitation. This talk, I will ask -- not cover more details about the implementation. But of course our future work includes extending our work to support more features and OCaml such as punctures and module step and also do systematic performance evaluation in the future. And to validate our design, we have imported to libraries. And first is you screen fusion library. Which was originally implanted in MacoCaml. And journalist generally speaking porting code from Medi-Cal the Mack O camel is relatively straightforward as the two systems share very similar staging annotations. And the other is the formatting library. And the rest of the talk I will use an example very similar to this formatting library to demonstrate how you can write programmes. In the MacoCaml.
                 So for this example, our goal is to define you C like print style function. So here, this slide just puts you print interface in letter C, which takes the format and then sequence of the argument and then view back the formatted stream. So the function like print after in our OCaml we need to define the format of generalized algebraic data GDP in our system. So here we have the type, data type format basically says that if it is AB format, and it basically prepares any number of arguments to B. And here it only shows like three data constructors but you can extend the definition to support more cases. And if it is the integer, then that means that we need one more integer argument, from the programmer. And if it is literal, and we are giving you string input and we can also concentrate two formats. And for clarity I also use the percentage notation would just be infects alias for cat. So for example this let pair definition here gives you the format that we have seen already in the previous slides. Which takes two integers and gives you the two port of the two integers.
                 And we can implement the print F in the MacoCaml through the CPS transpiration as an interpreter. And here, the print K is just the interpreter of the format that says that okay if you are in integer to the function that takes in extra integer, and put and if it is literal then basically because it is you CPS transformation. So the function takes the UK as the initial integration and if it is you literary it basically just passes the string to the combination. And if it is cat concentration then we first processed this and then switch back and gives you back the letter are and I give you back under why and then pass the concentration of X and Y to letter K. And you can try this. And you will see like this gives you the desired behaviour. But you don't need to understand every detail of this definition. The point here is doing print letter F this way is not efficient. Because print F is essentially just the interpreter of this format. We want to eliminate this interpretation overhead using macros.
                 So this slide shows you how you can do find print letter F is you macro in MacoCaml and again we don't need to understand every detail but for this definition. But the important thing is the only difference between this definition and the definition in the previous slides is really I just changed some type of the argument to experts and then start inserted the staging annotation here and here to make things work. And the print F really just print the K some initial communication which in this case identify function.
                 And with such definition of you print letter F we can generate coefficient for you specific format. For example if you print F on you pair format that we have seen already and the results, it will return you the function that takes exactly the right number of arguments. And at the compile-time, you can run time code this impaired onto in integer input and it will give you the format string.
                 So to see more applications of MacoCaml, these come to our talk at OCaml workshop this Saturday and where Jeremy will tell you more about how we can write things and efficient generic functions with MacoCaml.
                 All right, to summarize. So in this talk I have presented the MacoCaml which is designed for compile-time code or generation for OCaml. And we presented in novel design that unifies the staging and macros and present you more for formalizing with staging macros of modules and references. And we prove that our TAP system is sound and we enjoyed our practise such as best distinction. And we provide implementation for OCaml with two important libraries to validate our implementation. And with that I am happy to take questions. 
                >> GABRIEL RADANNE: All right. So there we go. 
>> Hello Will Brayton from Brown. Can you give an exhibit of you kind of macro that you can express in MacoCaml that you cannot express in met OCaml, can you give us you sense of how the added expressiveness of the features you've included give us you wider range of macros that we couldn't right before?
                >> NINGNING:   That is you great question so I want to go back to the basics and ask lane the difference between the MacoCaml and the meta- OCaml. Is not likely at any expressiveness in the sense that we can add more macros. But is more like meta- OCaml is designed for you runtime quarter generation. And MacoCaml in this talk is designed for compile-time code or generation. And then of course like the trade-offs between like at which stage you want to do quarter generation. So for example if you want to do it at runtime that maybe you can make use of some of the runtime information that are only viable when you try to run the programme at the OCaml time like for the exam will in our case like we have very explicit face decision between you compile-time any runtime that allows us to show like practise of our programmes. 
>> Okay thanks. 
>> Simon Peyton Jones. What is the difference kind of you question, and the popular Lester got yeti paper about template Haskell, it is exactly in this case, can you show in Libya oh demonstrating the Haskell and OCaml, there's some innovations there but I haven't got them from your presentation.
                >> NINGNING:   Yes so generation, that's the reason the true language have like you different set of features. So the work I had left, to give you little bit more context. It's about combining compile timed cogeneration. With tech classes. Which is the future that not in OCaml for example in this work we need to deal with teachers that are in OCaml for example but in this work we need to deal with the features that are in OCaml and not in Haskell. For example MOD also references and also more technical differences that work we did really interleave typing with compared to the time corner generation. We just sort of say okay like lifted the top of the programme so they will be value would be for the rest of the programme. The sort of gives you notion of comparing coming evaluation. And in this work we really like to make explicit that we have like you typing role that actually do called generation at couple compile-time. I think art design of the technical is actually largely inspired by your original paper on template Haskell. 
>> Okay thanks. 
>> Hello there-- from Jane Street. I was wondering you have all your compile elation stages as negative numbers as this leaves half the numbers on use. Is there you meaning to positive numbers or you decide to go with negative numbers for sort of other reasons?
                >> NINGNING:   That is you good question, I think people use numbers like in different ways in different work. And for us, sort of, and you lot of cases we focus on the compile-time commutations where the levels can go negative and then also working on like multistage programming where you can have like lots of quotations. Diagnostic condition, and you also have like very large. So we don't like really have multistage programming in this work. So we have focused only on half of the neighbours, but may be in the future we will support multistate programming and that we could use all the numbers. 
>> Rate, thank you. 
>> Hello, Matthew Platt. Your system compile supports compile-time state. I'm wondering if is that important to the kinds of macros that you want to write? Or is just something you have to support because it is there in the OCaml?
                >> NINGNING:   That is you good question, it is set up like host, we want to support competition with references to show that we can do that. We can do it in the tab safely. But we don't really have you very significant use case of that feature so that we are actually looking like for applications back from the community. 
>> Okay I can talk to you about examples later. Thank you.
                >> NINGNING:   Okay. 
>> I have you question. So one thing that is you bit tricky using MacoCaml quite often is when you want to use local definitions inside, local type definition in particular. And here it sounds even more tricky because you have an obstruction barrier. That could hide in definitions that want to put inputs in your macros for example. Can you talk you little bit about that?
                >> NINGNING:   Yes that is you great question and that's why have the sentence of implementation. We want to make sure that if your module has you definition that we don't want this to finish and to appear in the code generated. So there is some ongoing work, like applying that closer, mentioned that could deal with the situation but still we are working on that. So is actually future work. 
>> So, this might be you stupid question. [Laughter] but my intuition is surely for the difference between you state stage met programming system and the macro system is that the microsystem you have sort of got it except the syntax as input. And it produces new syntax. And the staging system, or at least one of the differences is that you have you function that can take arguments of you know any type. It is not necessarily consume that certain and books in the syntax got you have to expressly quote arguments. If you have the inputs and syntax that produces syntax, it seems like if you have that in your calling the macros, has my intuition for this just been incorrect or is there you particular reason your calling is macros rather than you know splices in like you stage programming system?
                >> NINGNING:   That is you good question. I'm not sure like macros are the right terminology for this particular kind of work. Because our macros are really different from connectors in the bracket system. We sort of use macros to being compiled. So basically bindings of able at you capital time. Or at the level. -1. So there are in our paper we have you very extensive comparison. 'Tween our work and the macros in the bracket system and we show like the examples where the microsystem's connection to give you like you very weird result in you sense that were you that this programme is like well staged and then after the macro expansion phase it gave you runtime arrow and then it's like that. And so we sort of think that we have you more like unifying the design of the compared time findings and staging that is not necessarily about the macros in the record system. 
>>  That make sense. Thank you. 
>>  Okay one question from the discord. And when to work ask if the macro OCaml you separate compiler or it can be installed as the preprocessor in existing OCaml open switches.
                >> NINGNING:   Can you ask the question again? 
>> Can you install you separate compiler or is it you modified compiler or processor?
                >> NINGNING:   It is available as an artifact so people can try. I think it is currently you modified compiler. 
                >> GABRIEL RADANNE: Thank you and let's thank the speaker.

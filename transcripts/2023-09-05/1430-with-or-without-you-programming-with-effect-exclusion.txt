>> NINGNING: This is the last session and it has a very cute title, with or without you: Programming with effect exclusion. And the talk is given by Matthew. 
>> MATTHEW: Thank you, I would like to give by get beginning with a tour of some open source repositories and github. And will start with this repository from Google. I'm most interested in this documentation. We look at this typescript example code. This is what the handler function must not throw any exceptions when called. We can take a look at another example here. The event which is an event certification library. And here says the callback must not call any function that modifies event base. Notify this an event of the event base the ads or removes any event to the event base. And doing so is unsupported and will lead to undefined behaviour likely to crashes. Decred crypto currency library, written and go and here we have more documentation that says it must not call any connection manager methods during induration or else result and deadlock. And finally we have Java example, log back, which is logging framework, it says implementations must not close the underlying output stream. Which is the response will give the owning 800. So is not hard to see what the patterns here. In each case we have some criteria on saying that we can't do something. Can't throw exceptions, can't call us a certain function or class of functions. Can't close something. And the consequent as of this are catastrophic for our purposes. We have undefined behaviour, crashes or deadlock.
 And to generalize what we have here. And the condition from correctness and excludes the execution of a particular effect. And her goal for this research is to enforce effect exclusion at compile time. Effect systems exist and they are capable of doing this to some extent. Obviously, we can within the fact system annotate a function with the empty set of facts and will and force that is here. And it has no effect. And higher order functions also do this. And have empty set the parameter. Saying that the parameter F must be pure function having no effect. And going further, we say that potion has single effect. We say hello function, right to the counsel. So has the only effect has the counsel affect annotation. Sufficiently, abstract programmes need some sense of effect polymorphism. So this map function is a standard fraction for mapping over a list. But here it has an effect variable. Which is the same on the parameter after as on the effect of the function as a whole. Which means that the effect of the function as a whole is going to be the same as the effect of applying the function after once. And finally we need the sense of effect composition. If we have two combining functions resulting function needs to be whose effect is the union and some sense to the component effects. So this is how possible this most programming, the effect systems today. But is actually not enough. And that is because there is a bit of a subtlety to the definition of our effective exclusion. It is a condition for correctness. Which excludes the correction -- execution of a particular effect. But implicitly what we are seeing is that we want to allow every other effect. And is not something that is possible simply with the unions of sets of effects. What we really want something like this. Effect subtraction. We want to be able to say that we can have any effect except a particular facts. And that is what we have here. We have the snow throw function which takes in function Fas a parameter. And the annotation and that means that function F can do anything all except for having the throw effect. And this is what we propose to the type level. And we take a look at this body of function. We have coordinating needing construct at the term level.
 So here we have something that does the same thing. But we have said that exigent is not allowed to, have the throw effect. So that we have this type level. Effect subtraction and we have this term level without construct. And we can see that in action, and a few examples, we want to avoid blocking the UI thread. We want to avoid blocking the UI thread because that leads to freezes or undesirable behaviour. Want to ensure that the listener that we register is not going to have the blocking effect. And so what we do is that in the body along click we define our function L in the body of the function L we execute the listener on some event E. But we require that the execution not have the Black effect. That means that when we try to execute on click to register a listener, in the first case, that's okay. We registered it with the do print line. I would just print to the console is not going to block. In the second registry that we do there, on click from this lambda which will read a line from the Council. Will reading a line from the Council is something that can Block. So this is rejected by the type system. Is another example we can avoid recursive event listener registration. So here we have another on click function. But we want to prevent this on click function from registering other event listeners. To do that the first associate with the on click function, the effect of register. And that means that anytime we call and click we will have the registry effect. But in the parameter F, we require that parameter lacks the registry effect. So that means that an effect F or any function F that we give on the  click function. It could never possibly call on click because the calling on click has the registry effect which is forbidden by the on click function. And as the last example, I will invite you to come think back to 2021 and pretend that you are a Java developer. Who happens to be using LOG4J and because it had this major on ability where we were able to have a moat code execution through networking and class loading. But if you were happening to use a system that had effective solution. And that fact system had networking and class loading as effects and you only need a simple longer that did the simple logging task that did not need networking and class loading. Then you can totally sidestep this issue. This vulnerability by declaring a safe longer which lacks the network and class and load effects. I will take a look now at the formalism. We defined a lambda complement calculus. Is a simple lambda calculus augmented with out an expression. The same expression we saw before. We have an abstract machine which executes, view is and we have a type and effect system which uses set formula based effects. And we have a --type inference using Boolean unification. The syntax for language, it looks like this. Most of his standard, the two important parts that have the dual expression. Which is executing an effect of F. Of and then without expression which is the forbidding of the effect F from occurring. The abstract machine that has two components, first the expression E that we are working on. And then the stack K which is made from frames which are either let findings or will without frames. And so a stack can look something like this. Where we have a bunch of light bindings and then these without frames. And then from the stack that we can get our list of what is forbidden by the context. By looking at the frames that are without frames, we look at the affects forbidden their. And we get the forbidden effect set.
 The first group are those that do not modify the stack. And then include the standard rules for definitions and lambdas were we simply substitute in the body of the lambda, the variable in the body of lambda. But the dual expression is more interesting. Here is where we actually enforce the effective exclusion. Here we are trying to execute the effect F. In order to execute the effect F we require that F the not be forbidden by the context. And if it is forbidden by the context that we cannot advance. Of course we also want to push these frames onto our stack. So when we encounter without expression, we push onto our stack and same with E lead expression. And once we arrived at a value in our machine, then we can pop things off of the stack. So here I will go through a quick example. This is the same on click function that we saw before. Where we for bid blocking in the listener. And we apply that to be function which clearly just blocks immediately.
 Every bit of substitution we can start with this is our abstract machine. It is just the body of the on click function apply to that lambda that blocks. With the empty stack.
 We perform reduction by one-stop. Substituting of the lambda for the listener. And we end up with this. We now have a without expression. We push the onto our stack. And now we just have a simple lambda application again. Which we perform. And now we are at the point where we are trying to perform the block effect. But the block effect is clearly forbidden by a stack here. So we cannot advance any further. We have gotten stuck. And of course we never action want to get stuck and that's where we have a type and effect system. So the syntax or system looks like this. Are type consist of variables, constants and Aero types. Where the arrow types are labeled with the effect. And then effects are consistent of these suspects we have the variables, empty sets, singletons and then to complement said complement set union and set intersection. And then of course because we are primarily interested in the subtraction, we have this syntax for subtraction. And finally we have this notion of Boolean equivalence. Because any set formula can be accessed in any infinite number of ways. We had this idea of equivalence but just as all of these ways of expressing the same set indeed are equivalent. And with this I will present a few of the type rules. Here we have the do expression.
 The rule is very straightforward, we try to execute the effect F he inferred effect for that expression is the set of effects with F and it. The without expression is also kind of what you would expect. We inferred the effect of some expression E and then we required that effect lack the F be effect that we are forbidding. And in fact the Boolean equivalence rule says that if we have that you fax or types that are Boolean equivalent then they are substitutable with each other.
 So our system has the standard properties of progress and preservation. And also has the property of affecting safety. And the formation of effect safety is slightly different from the standard one for effect systems. And that is because most effect systems are interested in being sure that whatever F effect we are executing is a member of this allowed set of effect. But we are interested in the opposite. We are interested in making sure that the effect we are executing is not a number of the forbidden effects.  So is a complementary idea but the proof ends up being approximately the same. And so system is an extension to the programming language effects, it's written in about 10,000 lens of code. We support this VS code extension which includes all IDE features such as syntax highlighting and your reporting. We have evaluated our system in a case study of 59 programme fragments. For which we, as we saw before, they have some documentation expressing the fact exclusion. We have given them type of the signatures that will enforce the fact exclusion. And we will also provided proofs of concept, to runnable example applications that demonstrate our system and practise.
 For the case studies we first performed data collection. Where we look at github coasters. And search for the terms like must not call, must not throw, must not raise, things like that there are expressing effective solution. And we get the large table of examples that look like this. And I would just like to read a couple of these to you or just one. And hear the and all DBI AI system says that the job must not throw an exception, an exception from within the job, it will crash the programme. And what we saw here is not only are these things present in a lot of code. It seems like the authors are very passionate about it. A lot of capital letters, a lot of exclamation points and in some cases some vague threats. And so this is nice because it is really demonstrate in our system is not only present, or our system is not only desirable but important to some users.
 So anyway for each of these systems, we took the original code, and took in the documentation and we translated that into a signature in the deflects language. Where the effect exclusion will be enforced. So here the decried example that we saw at the beginning, we took that must not call connection manager methods criterion and we moved into the signature. So here the function F could never possibly execute a use connection manager effect.
 Soon addition to these case studies, we have a couple proofs of concepts. The first is the GY library which prevents blocking on the UI thread. And we have an event bus library which will allow placing arbitrary restrictions on the subscribers to the event bus. The GY library looks very similar to the examples we saw before we have this listen function, and we require that the listener that we register does not have the effect blocks and then we listen function, give a lambda that says print line because that's nonblocking operation. But we cannot give it a lambda that says sleep because that would block which is forbidden by the effect system. The event bus library is a bit more interesting. That's because we have this type that is parameterized by in effect. You see that we have this event bus declaration. And the first type parameter is the effect parameter. And that is the effect of the function that is contained within the event bus.
 And then we have these two functions of nonblocking and non- throwing, and the stake in the event bus and enforce that the event bus lacks the block or throw effect. Then the subscribe function requires that any function F that we subscribe to the event bus, that the effect of that function must be a subset of the effects allowed by the event bus. So you can see this in practise at the bottom. We create event bus. We declare it to be non- blocking. And again we are able to subscribe a function that can say line. Because that's not blocking. But we are not able to subscribe if and when that sleeps. Because obviously that is a blocking operation. So to conclude. We have shown effective solution as the desirable behaviour or criterion and a lot of real-world programmes. And is the forbidding of one effect while allowing all other effects. We formalized our system in the lambda complement calculus. Which has a full soundness and affect safety with full type of effect inference. We have evaluated our implantation with 59 programmes recast into flicks. And we have provided to example of occasions we have shown and practise. This is an extension of the programme language clicks, so it's not merged into the master branch of the language but if you're interested in the flux you can find it at flips. Thank you. 
>> Yes I wanted to ask about teal calls, looking at your semantics, a term that appears under without is not until position. But if you're type system can rule out any dynamic activity, can get your implementation, can I make a optimize Asian tell call to a function under without? 
>> Can you repeat the question? 
>> Is that position that appears without -- under without, so your tail call to off without block, is that call going to be itemized your implementation? 
>> Yes it can be optimize. 
>> Let's take one question. 
>> Hi, so first of all I really appreciate-- the fact that you have a user study. That something that should be more in our kind of-- [Speaker away from microphone] is it okay now? 
>> Yes. 
>> Really want to highlight the user study and say that I really appreciate and that it should be more presenting our community. Can you talk a little bit about inference? How do you solve the Boolean aspect of it, that aspect of it and do you have subtyping for it? 
>> MATTHEW: Yes so the first question is regarding the inference, and the effect sense. So we use the bullion unification so these are Boolean algebra is. So bullion unification allows us to do this. In the nice thing about Boolean unification is that it gives rise to most general unifier's. And that nice part is it works very nicely with Henley Miller and others. And the second part is our system does not support subtyping. 
>>  Yes interesting that you've used unification, I've worked on a system with building unification myself. Was interesting to see. A question I had was in my extremes, putting it unification gives you emotional unifier's like you said. But can give you generate quite big and large exceptions of Boolean expressions that might be difficult to read. Have you found this problem? 
>> MATTHEW: The short answer is yes. So in a lot of cases the ultimate expert in that it could be reduced down to is very simple. But indeed it is very tricky problem to reduce these. And we get tomorrow and more complex expressions that we end up with these giant things that and that not being a problem. So is a matter of future work. Thank you. 
>> Hi there. I want to ask about your effect F the capital F and your syntax is that some kind of fixed range of effects or can you don't know, declare new effects to expand capital F and can you attract over effects? Do you have an effect polymorphism? Did you seem, in your syntax you did seem to have think they were these-- like effect variables. It might matter whether the variable has been instantiated yet or not. So it is just a collection of questions around whether effects are fixed or quantified? 
>> MATTHEW: The universal effects are a priority kind of. And the formalism indeed that is the case. 
>>  Okay so that is indeed how you can do the effect complement, it's respect to the implicit global set of effects, is that right? 
>> MATTHEW: In the formalism yes. However in the implementation we assume the infinite universe of effects. So we have the effect complement it is saying with respect to this infinite universe with a co-finite son of effects. 
>>  So that means that the implantation doesn't correspond to the formalism? So that would be, how do you know that implementation is right? 
>> MATTHEW: That is a good question. It is a very small step between the two. It is true that they don't correspond exactly. Yes. 
>>  And the last part was about effect polymorphism, whether you quantify over effects? 
>> MATTHEW: Yes we do and support effect polymorphism. So the Boolean unification has these include variables and so yes part of the syntax is having these effects. 
>> We still have more time if you feel like taking more questions. 
>> Yes. I would like to ask about the effect exclusion to try to write my head around here, so don't have familiar with this. But if you could choose like will pull them off a basis for your effect type system and then if you go with French school thought then there's a system. Then that why do you do the remake all why they are presence flex? So my question is really what is the comparison of relation to the type of system and how is this different? 
>> So you're talking about dash makes two so is talking about present flax, it could be polymorphic in your presence and one of them in your absences saying I'm here or I'm not here. And very select to what you are doing here and try to understand that relations. 
>> MATTHEW: Okay I'm afraid I'm not comfortable. You waiting on that right now. But maybe we can talk after a bit. In 
>> I think I can explain and extend a little bit on this question. I think in general like there are some languages that model effect annotations like neural types. And there is of course like a very long history like on road typing. Where is work on like for example raw concentration and the subtraction and also the work there, and like what is the general relation between the way that you did this work and how do you compare it with like the system leak that has these kind of features in their prototyping and maybe you can use that kind of system to model? 
>> MATTHEW: Yes I think it is really interesting but I'm not sure I'm quite able to answer that right now. 
>> Yes let's take one last question. 
>> Yes, thank you for the topic I'm wondering a bit about run a lot of the effects in your syntax. The effect seems to be somewhat constant. And one exam will was this connection manager, the documentation manager said something like you are not allowed to call if connection manager methods seems to intent on this connection management as fast as parameter. But your specification seems to preclude any connection, and natural effects on any connection, natural object whatsoever. Is this true? And can you limit the effect of the effect exclusion to a given connection manager? 
>> MATTHEW: This is a very good point and in some sense a weakness of our system and indeed there are a lot of cases where we want to exclude only effects as they relate to a certain object or value. And the system is not capable of expressing that. Thank you. 
>> Okay let's thank the speaker again. And this is the end of the session and we will have lunch I think at the next room.

                >> SATNAM: Welcome to the first talk on the session on concurrency distribution. Sit down and check those so we can get started. The first presentation will be by Simon Fowler from University of Glasgow. 
                >> SIMON: Thank you for the introduction and thank you everyone for coming to my talk. So today I'm going to talk about some joint work with Francieszek Sowul, Duncan Paul Attard, Simon Gay, Phil Trinder about how we can help us assure the safety of actor style languages. So the communication concurrency is difficult. So we can very, very quickly getting hot water as soon as we have more than one thing. And to help tame this complexity we have a class of linkages called communications centric programming. Things like Erlang, things like go and Alexia. And put really munication and concurrency at the heart of their design. And here we have isolated threads which communication using explicit message passing. And this allows us to avoid many of the pitfalls of shared memory. For example, we don't need to worry about the order in which we acquire a lock, for example. But the most certainly not a --so we have classes of, occasion centric language. We have channel baseline which is. Things like go, and here we have anonymous processes which can communicate over channels like buffers for example. And here we have ordered and bidirectional communication. And effect these things are very easy to give types to. So and Go would you have a tile work and sent and received things to type in for example. And actually we can have much more fine-grained type systems for channel based linkages. Things for like seven types were we can say okay I want to go and send to and just to receive a ball and an end. The kind of, not so nice thing about channel languages is they don't have such a nice tradition sorry. And you know, actor based linkages. Things like Erlang and Elixir have had real success in developing reliable distribute its systems. So here we have a different, negation models where we have named processes. And each of them are associated with an incoming message queue known as a mailbox. Here we have unidirectional and possibly unordered communication because we can potentially take something out of the mailbox. And this makes things a lot easier to distribute. But a lot more difficult to type. So just to start with an example here. I will start with the example of a feature and this is typically a placeholder variable. Where we can write to it once and read from it many times. If you have multiple writes then we have an error. So we start off with the empty future. And what this function does is we wait for a put message, when we get that put message along with some value of X. And transition to the full future state. Now we can receive get messages in this point but we don't process them yet. Then in we are in the full future state we can start processing these get message and when we get the get message we process ID which we send the reply and then we recursively go and process the remainder of the get messages. If we get another put message then this is an error and we need to go flag this at runtime.
                 The main fraction ties everything together. So we spawn a future, we put it in a message and then we send a get message along with her own process ID. And then we received a result in printed out and here I'm saying that we print out the results + ten. Now this is a fairly small programme but we can still get it wrong in a lot of different ways.
                 So the first thing that we can do is just violate the protocol and just send to put messages. And at this point what we get is also will rights errors manifesting itself at one time. And could also not send a put message at all. At this point, the future will be waiting forever. And we could then forget to send a reply message, even though we have made the request, the request will never be fulfilled. And be hanging forever in the client. And what we, another thing that we can do is potentially have an unexpected message. So here's surprise. This might seem an oculus but this, if it is in a tight loop for example that we could soon get a memory leak for example. Another thing that we can do is have a payload mismatch. So here we are sending a put message with the type hello. But when we are receiving this or sponsor you're having a result + ten. We try to add tend to the string.
                 The list goes on actually so we could also do a self deadlock. So here what we are trained to do is we are trained to get the reply before we actually send the request. And of course here, we wait forever as well. So small programme, awesome ways it could go wrong. So this kind of actor style communication has been looked at in terms of the types system in the past. By Ugo de Legiro and Luca Padavani. Publishing lovely paper in 2018. And here is a tight mailbox with a mailbox type. Out each mailbox can have many send references, so many different processes consent to the mailbox but it must have only one receive mail one receive name. So the goal really of this type system is for the sends and receives to balance out. So is have a look at the patterns which Form 8 communicative regular especially. So this is an Adam, we have conjunction this is patterns E and after, since this is a communicative dealer excursion this is the same as saying F and E. And then we have the disjunction this is pattern E or F. And then we have obligation, so 0 or more copies E. Of the empty mailbox that contains no messages and finally the unreliable mailbox. This is never will write this but this is used for type checking to show that something's going wrong. And now we can give some examples from our form of our future programme earlier. So to start off with, the future will have the empty future time. This is the received mailbox type or the mail box contained a put message and many get passages. We have the full future which can receive many get messages but exquisitely you know put message. You can have a client send which is the obligation to send a reply message. And then finally, the client receive which is a receive capability saying that the mailbox contains single reply message.
                 Now they worked in the setting of the process calculus. Now process calculate really distilled on the expense of concurrent communication. Here we have things like parallel composition. We have things like name restrictions which bind the name feature future within the particular school. But they don't look like programming which. We went want to write anything like that. And essentially this is because a process calculus shows a snapshot of the concurrent system. Or as we want a programming language. Which must be able to describe the programme is rights is something like them. We skip forward a bit, we devolved a programming which for the mailbox calculus. And we develop this pat after the kids TV show in the UK called postman Pat.
                 And essentially it looks like this. And it looks a lot like the Erlang code we saw earlier. Okay now I will show you a demo of the tool that we have done. So what we have got here is the future example from earlier. It is essentially pretty much a transcription of the court calculus that I showed. And X we now do future, at this point we can see that is evaluating successfully. So now we can start doing multiple puts for example. And we can start screwing things up. And here we have is we have the inferred type, put. Put. Get which is not supported by the annotation that we have got hearing saying put.Star get. And we could delete the put together. Again that get is not supported by put dot get and we could let's mess this up and do hello, the payload. And which point we have the type mismatch.
                 All right. Let's do, shall we do the self deadlock? So we put that there. And the; there as well. -- and the Sunday code there as well. That's the first time of action managed to get that proper error the first time. And is now saying that the mailbox variable itself after was used after being consumed by-- thing. Okay to know all of those areas we saw earlier, we cannot actually rule out statistically using the system. Now I want to firstly go over what is hard and then how we did it. So the first big challenges this distention between static and dynamic. In the process calculus, we kind of know the names a priori, and they use this to good effect in the original mailbox calculus paper in order to have a graph based approach to alias control. In the programming language you can't do that. And the terms like new, which at runtime then evaluate to freshening. And then on top of that we have got things like sequential composition. How do we handle that? Do we handle things like variable reminding and aliases?
                 And kind of more specifically we get lots of name hygiene problems. So what we have is free book, really what we want is we have got this mailbox, we use the open ask, and then we receive the cause and not have access to it and the free. And however we can quite straight for the infected do some programmes where we do this naÃ¯vely, we can actually use that X after freeing. We can find this is easier to do with linear type system but we can't use the linear type system here because we need multiple references to the sea mailbox in order to send it to. Now you might think well couldn't you just make sure that you are guarding on the variables that your guarding on? Don't occurred then in the body of the guard? And that works with the rules out of the problem here. But we can be quite straightforward. Things like the variable renaming and things like evaluation context. And then we need to remember that this is concurrently years, we might need to end up inducing aliasing via communication. So the way that we get around this is taking use of the quasi-linear typing. Quasi linear typing was introduced by Kobayashi in the nineties. And the paper that we use is closer to at all sharp and Mycroft bit later on. And the idea here is that we can use each reference once per process as a kind of full reference. And many times is what's known as a second-class reference. So the full reference or the returnable reference, these are things that we can let bind and we can return them as part of expression and we can guard upon them. Where is a second-class friends can be guard upon and it can't escape its go. Them what we can do is we can enforce an ordering constraint which means that the returnable reference must be the last occurrence of the name in a particular threat. So just to give you some examples. Here is our client example from earlier. And we want to see how this works within the self reference here. So we start by sending it to the future as the payload to the get message. And that we can do as a second-class reference. And then we guard upon. Which needs to be returnable. And I should have said that the little white circle is a second-class reference and the full circle is first-class reference. Then what we can do is we can rebind it, in the receive clause, so that itself is a binding occurrence and then we can free it.
                 Now if we then try to do the same thing with our use after for example. Can quickly relist out. Because regarding -- we are guarding on something. So here we've got the received message and we have got the full reference. And then we have these two occurrences down here which are only second past.
                 So this all works you know, the mailbox typing works out. Is what we want to do is want to go and cancel the sends and receives. So if we have two sends, and we have is a send E and F. And what we get back is combining send E and them receive e and F. Then we get back to something which allows us to receive letter F. And that's communicative operation. There are many different ways that we can write semantically equivalent cut mailbox types. Basically what we do, the court technical thing that we uses subtyping to rewrite. Semantic leak equivalent forms. Where we can apply these two rules.
                 We also have common nations for usages, we can combine the two second-class usages or the second-class and returnable usage, note that this is not minute to we cannot combine to returnable types.
                 And to see how this is used, here is the type annotation here, it is not needed in the actual tool. For example. We are doing here is checking that the subject of the let has a returnable tight. And we have got the sequencing of these two instruments which ensures that the mall box types combine correctly and have these same quasi-linear well formulas properties. And I will just tell you about derivation here. What we are doing is creating a new mailbox. We are sending and receiving them and freeing it. And that's do a derivation here. So the type a sand, we need to type context where we have got X type sent. And then in order to type the receive guard we need something of type receive letter M with a little circle. And combine those two things together we have something which is now the empty mailbox. And we can put that in the context of the overall expression. So new has type receive empty email box. And we can use that and eliminate using the left and is type of will under the empty context. So we have a nice that a theory here. And so we've also got preservation. This is if gamma is reliable so doesn't contain anything with the unreliable mailbox and. It is well types and then it takes a step and then the reject also well types. And as a corabarie of this, we have this that we will never get into the situation that we have done something we should have never done. And that is quite hard. We need a frame step representation it requires quite extensive reasoning about context and quasi linearity. And the next thing that we have is the algorithmic type system. So that's a declarative type system. Is nice to reason about but we can't implement it as is. And this is because essential we have got this, if we are reading things bottom up, we have this nondeterministic environment missing. And we have to reason about the environment subtyping in order to see what we can combine. And it boils down to the pattern inclusion problems. So instead, of doing the usual way of writing a type checker. What we do is taking the known as a co contextual approach. Now the co contextual typing was introduced in 2015 I think it is. It is a lovely approach. And the idea is what we do is we produce a type environment. And set of pattern inclusion constraints as an output of our type checking algorithm rather than an input.
                 Now we use a bidirectional approach. So the standard bidirectional typing approach has two judgments. The first is a synthesis judgment, and here we say that hundred typing and environment gamma, we can synthesize type letter a for term and them. The second judgments is the under environment gamma, we can check the term M has got type letter A. And the backwards bidirectional spin on this allows us to do the following. And so this is the following idea and in 2015, I learned about it by the lovely bidirectional survey paper by the Dunfield and Christians-- and what we have got here is the term M, synthesize to type producing environment beta and pattern constraints and then we can check judgment which says that we can check the term M has got type and produce again environments theatre and pattern inclusion constraints. And the ideas we want to go and stay in checking mode as long as we possibly can. At the point that we get to the variable rule. What we can do as we construct a single environment saying that X has type town, and then as we go down the tree we can merge things together. Just to see how this works in the let roll. What we want to do is if we try checking the X equals M and N. We go firstly and check the body. And that allows us to inspect that type produced environment and allowing us to use that X has got type tell. Yes you check that tout is returnable. And then we can use that knowledge to reduce what we need to check to get the output environment there. And the two environments. And what we have is the entire let construct being typed. So we have some metatheory here as well. We have over them sound this which is essentially don't accept nonsensical terms. Sophie term is terrible in the algorithmic system then is the temple in the declarative system. We have got algorithmic bleakness, which says that we don't reject sons will terms. Sophie term is a typo bull in the declarative system than a checkable not synthesize about, checkable in the algorithmic system. And so we've implanted this and use a fairly standard pipeline. And we have are passing and then we have conversion to it explicitly sequenced intermediate representation. At this point we apply known closed form solution to the pattern inclusions before shipping things off to the said three sobered just make sure that everything is consistent. We have everything evaluated against the factor use case. Which was done in collaboration with our industry partners. And this is basically working with modelling robots on a factory for. So the idea is as a single warehouse, and we don't want more than two robots in there at once. More than one robot in there and wants, sorry. This is actually quite tricky to do with most session type systems. I mean it can be done in some I'm sure. But it is a lot more natural to do it in this kind of setting. And we end up with a programming style similar to something known as archetype which is a simple type way of doing things and act on. We've also doing a selection of the benchmarks from Savina. Here we can see all of these, we can see that they actually are all type checkable and under 100 milliseconds. So any obvious scalability problems. Same with the fact, factory study as well. And we can encode all of these samples from the original mailbox calculus paper, even though we don't have the same fine-grained alias control that they have.
                 Okay so just wrap up now. Mailbox types allows us the type of mailbox rather than the process. And today I've talked about the first integration of mailbox types into the programming language. And to do this, you really need a quasi linear typing to handle the many writer simple reader pattern. And then we go on to the sound to complete algorithmic type system based on backwards it by the rational typing as well. And there is lots of cut lots of things to do in the future. We have started doing some work on how to compile first-class mall boxes into actor systems. It will be nice to look at, going from a directional setting, and where we have something with more tape constraints for example. Morse officiated alias analysis. We are currently pushing really hard on the tool integration, in particular with Erlang and Elixir. And I think this can be used to get language integrations for behavioral type systems for other many writer communicate impurity in this. Like publish subscribe or text people. That's it. Thank you very much for your attention. 
                >> SATNAM: Thank you any questions? If you could say your name and affiliation. 
>> Thank you for the tool, you never spoke about subtyping and it seems that there is a very natural notion there which is regular set language inclusion. Did you consider it? And would you work? 
                >> SIMON: The question is what about subtyping? Subtyping is crucial to this. There are many different ways actually writing the same mailbox pattern. And we actually need subtyping in there in order to go handle things like inclusion of you know single atom in which that says we've got many for example. So it's actually critical. In the way that it works is we give a semantics to the community of regular expressions which gives a set of multicentric and at that point we can do just regular set inclusion. To determine subtyping. It is contrarian in some types and covariant in receives. 
>> Thank you. 
                >> SATNAM: Any more questions? 
>> Would be possible to put up some aspect of this using NASCO, STM, for the research-- 
                >> SIMON: That is a lovely question, if I'm understanding right, this is a standalone language we can do it with existing tools? Haskell an example because it's very rich ecosystem. I would love to try this particularly cloud Haskell, because cloud Haskell has got very similar thing were we spit out essentially a mailbox into something that can't be sent and we can then send many things to it. I haven't tried it, I have the same thought though and I think it's a lovely idea. I think it be really interesting to do. 
                >> SATNAM: Any more questions? If not then you can wrap up, a few minutes earlier. Okay that is good. Thank you very much.

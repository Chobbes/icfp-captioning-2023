                >>  I think it's working, yes, check check. They couple more minutes people coming to the session. 
                >> SATNAM: Okay I think we can get start with the second talk about this is one of the dissing which papers at ICFP. Okay we can start. 
                >> GAN: Okay thank you for the introduction and hello everyone! I am Gan Shen, am a student from University of California, Santa Cruz. And I'm going to talk about HasChor: Functional Choreographic Programming for All (Functional Pearl). And this is joint work with us three, Gan Shen, Shun Kashiwa, Lindsey Kuper. Together I'm going to talk about what programming distribute systems is like. So that distribute a system consist of collection of nose operating independently and a communicating through message passing following a protocol. Traditionally to implement such a system, developers write individual programmes for each node and hoping that during education will give rise to the correct behaviour prescribed by the protocol. As a simple example, if you want to write a client server protocol. Obviously there will be two nodes of client and the server. For the client Graham we might write something like send a request to the server and wait until we receive the response back from the server.
                 For the server, we might write something like we just see if the client from the client process it and generate a response and send it back to the client. Is this example shows. This individual programmes you sent and received to communicate messages. And it is crucial to ensure the send and receive messages with each other. Otherwise we will get communication arrows.
                 A typical example of communication arrow is a download. For instance, in the client server protocol, if both client and server are trying to send a message to the other, then neither will make progress in the system will deadlock. Although this is a simple and controlled example. And I'm sure most developers can spot and debug this dialogue very easily. But imagine this complex protocol where there's tons of, occasions going on. And having to pinpoint and debug a deadlock like these can be very painful. It would be great to have some language support that prevents us from writing programmes with communication arrows. To that end, several techniques have been proposed and the Cairo graphic programming is one of them. That idea of choreographic programming is that instead of writing individual programmes, the developers were a single programme that describe the complete behaviour of an entire distributed system. Because such a programme, a choreography, because the coordinates nodes in a distributed system just like choreography coordinates dancers move. You know choreography, send and receive combined into the operator. And this operator guarantees that send and receive are always match up. That there is no deadlock.
                 Additionally, choreography programme provides accomplish and process called and point production. Generating individual programmes to be deployed on each individual node. So with the choreographic approach the client/server protocol can be implemented as a single programme in this choreography, we describe both the client and service behaviour. Which makes the protocol manifest. Another benefit of the choreographic programming. A central piece of choreography programming is this squiggly arrow operator which we call Munich eight were-- it represents communication between two locations. And here in the first line the client is communicating a request to the server and when the server received the request it binds to that variable X. And the programme continues. After writing this choreography, if you want to get executable code to be deployed on client and server. We use the endpoint production which will generate these two individual programming that are exactly the same as the handwrote one that we saw before.
                 So that is choreographic programming. And we believe it is an interesting idea and want to bring into the functional programming world. And as a result this paper, would build task which is embedded to specific language for choreographed programming. And programming in HasChor provides a monadic interface for choreography programming were choreographies are expressed as computation's in a monad. Also embedded in DSL. On like private implementations HasChor doesn't require a customize compiler. So integrates well with existing HasChor ecosystem. And also with our embedding makes heavy use of F4 monads which leads to very natural realisation of endpoint production. Of which I was showing in a moment. And that choreographic programming looks like in the HasChor. Let's look at the standard protocol from the literature, the standard protocol. In this protocol the buyer is trying to write a book from the seller. And the book they want to buy to the seller, and the seller replies is the price and the decide to buy the book and the sellers send back. The delivery of that book, otherwise the programme would just in their. In the house court, just choreography is represented as a Mona, that return from some value. Here the career monad is the -- choreographed fees. And the bookseller choreography returns a value may be day buyer. And we have score values and intuitively why we need locative values, because in choreographic programming we have a global view of the system. So the values in the different locations will show up in the different programme. Which makes it possible for location to access the value that doesn't reside on it. So to prevent such behaviour, HasChor annotate each value with its location and we make this located value opaque and not immediately usable. To use it, you need to unwrap it by applying your own function. And HasChor provide these interrupted function you know in a very regimented way. We will try to show you in a moment. Additionally, the for graphic monitor is parameterized by another monad which represents the kind of local competition that kind of local computation that each node can do. For realistic programmes. Most of the time these monad will be a variance to it. And we are ready to implement the bookseller protocol. And the protocol prescribes the bio first sends the title that they want to buy to let seller. And we want to use these overly operator to perform a local computation. So here, the buyer is querying the standard and put to get the title of book they want to buy. This local operator takes the location letter L and the action MA and returns located value. At the location in the curio monad. And what is this local action MA, it has access to unwrap function that can only unwrap located value at the down location. This is the only place where it has HasChor could provide this unwrap function. And now note how this L is matched up with the location who's performing this. Mutation. This is how HasChor will guarantee safe access to located values. In this example, the buyer doesn't use the function. You will see it gets used in the later example.
                 Once the buyer has the title of they want to buy they need to communicate it to the seller and in HasChor we do these by using the communicate operator. So the communicate operator takes a pair of a standard location and the value at that location and receive the location and returns a value of the receivers location in the career monad. And the string of the bio location and after we apply the communicative operator, title prime will be at a string of the receivers location.
                 Going back to the book seller protocol. After receive the title, the seller now needs to send the price of the book back to the buyer. And we do this by writing this to lines of code. And pretty soon similarly as before, here is doing another local competition to get the price of both. We need to apply these function to title prime to unwrap it and use the normal function price of. And once I get the price of book now communicated to the buyer. Moving on.
                 At the stage of the protocol, now the buyer needs to make a choice. And this choice will change the follow-up choreography. And house court, first, the buyer use locally to make this position decision basically checking the price is within its budget. Now it needs to make a choice in HasChor and this count operator to express the choice. And the pair of the location who's making a choice. The choice of value at that location. And the function that describes the follow-up creators based on choice. And the operator return one of the follow-up choreographies. Here we can't count on the decision that buyer if it is true. And the seller will send a delivery date of that book back to the buyer. And the buyer turn that date as the result of the whole choreography. Otherwise the buyer just returned nothing as a result of the choreography. This is what the complete choreography looks like. Now let's switch gears to talk about HasChor internals and in particular how endpoint protection is implanted. So as we said before, the programming model of HasChor is structure around this current monad. Which has three effects, all printers, it locally for doing a local commutation, Tom for communicate in a message between locations cond and for conditionals. And the other hand the note to run individual programmes. And we call these programmes network programmes and they are expressed as the network monad, it has these full effects obviously needs to be able to send and receive messages. And it needs to be able to broadcast a message because when we implement the cond, the the location who's making that choice needs to broadcast the choice so the other knows no which branch to take. Afterwards. And also will not workprogram need to be able to run local computation. An endpoint, now we can think of endpoint projection as a process that links up these two kinds of programmes. The HasChor endpoint projection is defined as a function that takes HasChor monad, a location target location the location that we are projecting to. And generates a network programme that implements that location part of the choreography. And has not seen more than competitions with the seven effects. So you know we can think of this endpoint projection as interpreting the three effects in the Courier monad in terms of the four effects in the network monad, based on the target location.
                 For example if the locally affect Imperial, if the target location is location who's performing the local competition and we interpret it as wrong. Otherwise it is a now up. And if the target location is the centre, and we interpret it as a sign, if the target location is the receiver and we interpret it as a receiver, otherwise it is now up. Conditionals are slightly more complicated. As I said before. Inquiry graphic programming. Will take a decision such as taking one or another branch of a conditional. And other nodes need to be notified. So we interpret this as a broadcast. Know who's not making choice. We interpret as a receiver in the wheat recursively interpret the follow-up choreography. And now that we have the basic idea of the endpoint projection. To actually implement this one more question. Which is how do we interpret effects in the monad? And the answer to this question is for your monad's. For your monad's were originally proposed by Oleg, Hiromi Ishii. An the key idea are the monads is the term representation of effect for computation. Which leads to the following definition of free monad. And parameterize by affect signature letter F that specify of loud effects. The monad and his two constructors that corresponds to the two operators of the monads. And know how these three, is defined as algebraic datatype. Which means we can manipulate them just like the other datatypes which allows us to write an interpreter function. Then interprets the effects and the monad in terms of the operation and another monad. So here we interpret for your function takes the effect handler. That maps and effects in the F to the monadic functions in the G. And the function basically just full the handler over the monad. And for the return case, it's pretty simple, we just returned the same computation in the letter G cut for the dual case we call the effect Tandler on the effect then bind the results in the condition and you ration to get the follow-up computation and recursively call the interpreter on the following up computation. And in the Oreo and network monads, are defined as instance of the freeer know him monads and similarly, with all of the established and now we have finally been able to define our endpoint protection as interpreting effects. And I want to draw your attention to these drawings here. So essentially this and point reduction function is a call to interpret fear with a handler that translate the effects and the actions in the network monad.
                 Now we have the basic idea of the Haskell's free monad nation. And in the particular like a so the network monad is also defined as instance of Fremont. In the same functionality provided by Freeman, I had to support some multiple message transport backend. For example, HasChor to provide HET P backend where we interpret send and where we interpret receiving and sending and receiving as HTTP package. And local backend where we interpret network monads as threats and sending and receiving send and receive letter S. Writing and reading a second, so the types of operators I showed you in the side, actually use dependent types. As we all know, HasChor is not a fully dependent type linkage. So in the paper to actually fully implanted these we have to type shenanigans to approximate dependent types. And HasChor also support advanced choreographic programming pictures. Like the higher order demography's and location polymorphism. The nice thing about this is that we actually didn't spend too much effort on implanting this. Because we embedded this in HasChor, HasChor itself a higher order, and the polymorphic language. So actually do these features for free. And lastly there is also a case study and implement trying located in memory key value store in HasChor. So to conclude we represent HasChor the first embedded domain specifically which for choreographic programming. And we show you for your own apps can be used to implement and point production a very natural way.
                 And just one more thing. A week ago. We received a e-mail from a user outside of our group, who was trying to use HasChor to implement our sink long. And he complementing HasChor being very X is will to use. A nice thing is you don't need to understand any details about freer monads. The surface interface is very easy to use. And we believe that really shows HasChor sort of the tractability effectively of the choreographic programming. So if you are interested and want to try out HasChor, is available at this github ripple. Thank you. 
>> Popular motivation for writing distribute a programmes is to take advantage of imperialism, the programmes you've shown us so far are sequential. Is there a story on the parallel is him and if so, what is it? 
                >> GAN:  Can we use choreographic programming for parallel programming? I would say right now I will focus about concurrency. So I think eventually in the future we can use it like for parallel programming. But right now yes, we are focusing on having concurrent entities. 
>> [Speaker away from microphone] you have the lock base type but I don't see that constraint anywhere. I was just wondering whether you could statically bar against a location that wasn't actually the choreography? 
                >> GAN: That isn't interesting question, the question is how do we represent this location? What if we projected -- to a location that doesn't show up in the choreography? The answer to that is if we project a choreography to a location that doesn't open the court or free. We will get an empty location programme that doesn't do anything. It will still well defined the endpoint projection is its total function. Is defined for all location, if you projected to a location that doesn't show up, it would just do nothing because the graphic doesn't show up and it would just do nothing. 
>>  Allen Jeffrey from Newport. The short version of my question is one and versus applicable. And the slightly longer version is that the difference between those two is whether you can do it ahead of time, the endpoint projection or whether you need to do it endpoint projection during the running. I was winning if you have used cases. If you're able to do dynamic and point production? 
                >> GAN: So I suppose you're asking, can implement these using applicative functor, I would say the answer is yes and no. Because you have this conditional and choreography programming. The application function, you cannot tell you can alter the follow-up computation based on the result of prior computation. But basically there is this work and selective application recently, which a coordinator represent conditional in the applicator. So in that we can model choreography programming. And the second question is dynamic versus static? And run your programme and that's a time when endpoint protection actually happens. We have a use case for this. Right now, no. But yes, maybe there will be some in the future. 
>> I am Steve-- tweeg. The whole safety thing for location is quite clever, the whole unwrap thing. But is a lot of boilerplate paper. Is quite clever but I have a very stupid idea and you've to stop me when it's too stupid, okay? You introduce a type class application. And now X at L comes application. At Aro X, then locally instead of introducing the function that lets you on Boxee type just give you an at L instance locally. Would that work? Or what do you think? 
                >> GAN: Are you proposing a solution? [Laughter]. 
>> Yes and no, because I'm not sure it's correct. 
                >> GAN: I want to say I'm not sure, I agree with you that having that use issue is a little painful and want to address that issue. I did not quite fully understand your proposal. Maybe we can-- I'm curious to know. 
>> Carter Shownwald, TBD. I'm wondering if all of these problems work out even if the protocols were recursive? Even for a problem, because the projection for a missing counterparty depending on how the recursion is written, seems like it--? 
                >> GAN: So the question is the endpoint projection works for? The recursive protocol. And is actually so I mentioned in the case study on replica that we have a case study on replicated key value store. And that'll keep, yes basically in a reet service loop where you take some request, process it and send it back and then recursively go back. To take more request. And the EPP function works well for that. So I think we can handle it because of the protocol. Thank you. 
>>  This is a question for discord. Apologise. Three monads are great it would be possible to also have three replicas for running locally. For example to support --like to do batching etc.? 
                >> GAN: So I think the question is very someone to the customer, I've sort of forgot, but yes the short answer to this is yes, you need selective application from turn free functor. 
>> This all looks, yes close enough, we all need to eat the ice cream. It is all, it looks really nice you know the extreme seems to be nicely, mostly positive you mentioned a few little quirks here and there. But normally when we do these kinds of embedding's and HasChor,-- HasChor there are some pain points and the practise in the morning what are they here? In order to make this, if there are such pain points, would you want some additional features and HasChor or would you want to do this as a standalone thing which elsewhere? I know that there are existing choreographic programming the witches. Heavy learn something here that you can transfer into one of these existing? 
                >> GAN: So the question is are there any like inconvenience in embedding these choreographic programming in HasChor? Yes I think there is some pinpoints. Like having to use this function to make sure safe it access to located value. It is kind of cumbersome and if we were going to make our own language, I think we can like have a customized typing will. So anytime you access a variable. That is actually this type that at another location there will be a type aerobics you don't need to call this on the function every time. 
>> That seems relatively minor. I mean are there bigger issues? 
                >> GAN: Truthfully some other pain points. 
>> [Speaker away from microphone] 
                >> GAN: Eh? I experienced this you know embedding this and HasChor is relatively smooth. 
>> Well done. 
                >> SATNAM: And to wrap up there, thank you for answering all these questions.

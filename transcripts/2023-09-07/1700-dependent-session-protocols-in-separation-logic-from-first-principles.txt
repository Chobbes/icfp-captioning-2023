>> JONAS KASTBERG HINRICHSEN: I'm going to talk about Dependent Session Protocols in Separation Logic from First Principles (Functional Pearl) and this is a separation logic proof protocol so this is the first up of any good talk is to understand what the title of the meeting. So now these dependencies of session protocols, as you will see momentarily are a reasoning methodology for verifying properties about message passing programmes. So let's start there. The message passing concurrency as we have already seen is a nice well structured approach to writing concurrent programmes. In the setting, we often consider threads as either services that expose some unction out he. Or clients that consume that functionality. This is a paradigm in many of the state of the art link just such as go and scholar. One approach is that passing concurrency is that the bidirectional session channels which use the following three primitives at ascorbic we first have new channel which creates a new topic returning the channel and points which is C one and C two. And then you can have a sandwich sends the value over the next channel and point. And then on the other side receive and returns the next inbound value in order and returns it. Now this being bidirectional you can of course send and receive them both directions. Example of a programme written in this variant is the following. We create new channel input with C one and C two. We then fork off a service that acting as like a + to surface. In the main thread we first send the number 40 which is received by the service thread and then as to it and send it back. The main thread we receive the result 42 and finally uses a search statement that is indeed 42. Otherwise we would crash. So the goal of this line of work and the way of using safety is by using type systems. Now you can go further and get some level of fictional correctness by using refinement types and stuff like that. But going all the way we quickly end up with programme logic where we can prove much more property such as functional correctness.
 The trade-off here is of course that safety we cannot usually improve with automatic checking whereas functional correctness is something that we need to prove with manual proofs. In the message passage setting, we have the state-of-the-art session types. Where the functional equivalent at least one equivalent comes the frequency equivalent sorry. In the dependent session protocols which was originally from the were called the actors framework. And the two types of particles as we might call them. On the session type side, we say that we will send some integer and then receive some integer. Conversely on the programme logic side, we said that we want to send exactly 40 following by receiving the integer 42. Now in the realm of functional and programmatic pearls, we want to sort of defined minimal approach to achieving these solutions because it lets us clearly understand what is the minimum requirements? Now such minimal bridges exist. The notable is for session types, one notable version is by  Kobiashi and data. However on the flipside actors does not have such a minimalistic version. The goal of this work and thereby this talk is exactly then to come up with a minimalistic version. Now to do that we need to understand what the features of the actors are so that we can know what we need to obtain. Let's first, consider the programme, a simple programme, up for this we can have the two following channel and point ownerships which are propositions in our separation budget. That capture the channel in Channel 1 and channel to respect the following protocols. That's not to say that we first have first to send the number 40 after which point we can receive 42 and vice versa. Now this is the week and in fact verify our programme is both safe and it comes to the structure of our communication. What we can also assert this. Or verify that the search statement, exchange messages. The idea here is that the sending side will initiate these binders whereas the receiving side will abstract over them. Not also the binders are dependent, which means that we even the tail here and talk about the binders that was priestly instantiated. This is nice. We might get into even more complicated programme such as the combination of message passing and shared memory concurrency. Consider this folly programme that is the A four mansion programme decorated with references. In particular we first allocate a reference to 40. In the photo thread, we wait for the reference and then add to it to it and send back this unit flag indicating that the reference has been updated. Back in the main thread, we receive the synchronization flag and assert that the reference is now 42. Actris also supports this behaviour using so-called protocol propositions rather critical resources in the bylaw mall. -- in this case we dedicate this so-called reference ownership that captures that we have the included reference of ownership over the reference and it points to some value ask, this is very much like the linear type for mutable references. Beyond this Actris has many more features which gives us additional use and patterns. And a lot of the advance and features such as the channels, messages, at recursive protocols and subprotocols. And is fully mechanized and Iris on top of the protocol. So the motivation is was I that  Actris is implanted by custom bidirectional buffers. It's protocols are achieved with a step index, recursive domain equation proves are carried out using higher order state. And for those who are not familiar with these terms, hopefully sound so visually scary. The question at hand is how far can we get with the simpler approach? In particular, we want to start from the first bristles using mutable references as opposed to bidirectional buffers. I want to invariance instead of customer curses to make the equations and first auto go stay instead of higher-order. The key idea at hand is that we want to build one-shot channels. Based on the beautiful references and build the specifications based on the high order bunch of protocols. Which are built in with the IVR. And then we pulled session channels on top of our onset channels and then we want to obtain these dependencies in the proposed by nesting the one chip protocols. Finally, we want to recognise the whole thing based on the existing IRS. And is trying protocol. The contributions are than exactly three layer approach to the implementation but specification. Starting with the functional session channels finally imperative investors channels. A full recovery of the specifications of Actris and then minimalistic recognising in less than 1000 lines of Coq. And we don't have to much time for this before we finally concluded, we will briefly cover some of the additional features. We will start with layer one. The implementation of these is somewhat canonical. We have the first new which creates a new channel by allocating a new reference to non-pick you send which sounds a value updating the reference until it has value that has been sent. The way it point freezes the reference and return to value. With this API we can write, an example programme such as the following of our first create new channel. Then the fork of thread we create a reference of 42. And send the reference over and the main thread we await the reference and assert it points to 42. So the first thing I want to do when obtaining specifications for these channels to it and considered the protocols and channel permissions. The particles have 2 constructors. You can either be a sending or receiving protocol. And then you have a high order predicate that dictates was the resources that value has to cover. And then we have this sense into receives and vice versa. And then we have this permission ownership which is logical proposition that captures that you are allowed to own to use the channel import see in accordance with the protocol. With this we can obtain the following specifications. First, the specification for news is new channel given the true precondition. The result as of this new channel, along with two permissions, one for free to. Protocol letter P and one for numeral two. What this incident means is that one provision will be the descending one and the other will be the receiving. The channel that requires that we have a sending permission and that we prove that the predicate of the protocol holds for the exchange value. Conversely in the receiving side, we need to be on the receiving information-- we need to be receiving permission to have the receiving information. And the resulting value will then satisfy the predicate as a spread by the protocol. With these specifications in cut we can prove example as follows. And extend sheet a new channel, two new permissions. We can satisfy the sun instruction as we can satisfy the protocol predicate with the reference ownership that we obtained from allocating new reference. And we can prove this assert statement based on the received predicates that we get from the received specification. Now to wrapup the question is how do we actually prove our specifications? And the crux of this is to come up with a good definition for the channel permission. To do this we follow the standard methodology virus. Which is that we for smaller channel as a state transition system. Call that we have three states, first we have allocate our channel, then once when we sent and then finally will receive. Secondly, we want to capture the state as a disjunct of an invariant proposition. As follows, we want to determine resource ownership that is captured by each state. First and foremost the state has to capture that the channel isn't even a reference that points to nine. And the second state captures that, the channel and point the channel reference now points to some value in the final state captures nothing since the reference will have been allocated. Secondly, the second state assert ownership of the predicate for the value described by the pickle. Then we want to encode the valid transitions of our students in the system via those ghost tokens.
 That is by including this sending token in the second say. Which we can only go from the first to the second state beginning of the token. And for the similar approach, we can restrict transition from the second state to the third state to be able to access you can give up the receiving token.
 And the final step is to then give access to this variant. Through the sender and receiver along with the respective token. We do this by simply including it using this Iris an invariant proposition. The even actively captures the proposition at hand holds throughout the rest of the programme. And along with either the sending token of the receiving token on whether you are the sender or receiver. And now with this, proving the specification is somewhat straightforward and there is very clear on 1-to-1 correspondence between the encoded state system. And the actual specific agents. With this we have wrapped up the one coach and now we can put them in the Black box. Now we can focus on the layer to which we want to implant the function session channels.
 These channels being inspired by the work Kobayashi et al and Dardha et al, of and use the exact same notion of channel allocation. This is new, simply use the new of the online channels. Sending will first allocate the channel and then value of the exchanges in fact consisting of the payload value B and the channel can you ration C prime. After that we simply return the channel continuation. The received function is also exactly the same as the one shot channel. That we can leverage the fact that we can always have receiving something of this captured by the same function. Know what we get with a simple mentation is an emerging polarized bidirectional link to list. We can demonstrate this with the following sequence of exchanges consider the thread one and thread to that initially points to the same shot channel. First will have thread one. Sent 0 over the channel at which point it allocates a new one channel that itself .2. And we can do this again by sending one. And now with the structure we have implicit, asynchrony that means that thread to can now start receiving the values of the previously sent. And now we can you this iteration until we reach this equilibrium until both the threads point to the same one shot channel. At this point, the polarity might flip, and now the two can now send three. Which thread one can receive, this means that we have effectively obtained these session channels with bidirectional communication. The only crux of using these is that no channel sends at the same time. Which is an underlying property of the specifications given to the underlying one tract channels. All that remains is to come up with these nice session protocols, that appropriately describe the values that we actually are exchanging. And the first step to watch this, we can consider following protocol from the introduction. We would just want to describe the value. First we have this! That states that we are ascending protocol. We then use this syntactic sugar to say that the value exchange is in fact a chapel consisting of the payload value V E and then the predicates that captures that the payload value V is exactly the value W dictated by the protocol. And the second part is that states the exchange channel can you ration C prime involves the protocol were assigned to the tale of our station protocol. Now this is the dual that is because if you look at the implementation of the sand, we want to return the channel can you ration. Which at the end of the day should follow our own tail. Which means that the general consideration that we sent over to the original channel would have to be is tool.
 However is pointed out in the introduction, these protocols are bit to something stick and we would like something a bit more expensive. We can then achieve the appropriate dependence portholes as follows. And in particular the encoding of the binders using Existentials codification insider predicates. And then we feed this quantified value inside each of the protocol constituents which are treated as closures. Additionally, we simply include the proposition captured by the session protocol in our original one shot predicate.
 Obtain the receiving corresponding side is simply a matter of taking the dual of sending the poor, or also utilizing the tail in order to cancel out the dual that is inside the one shot predicate.
 With these definitions we can arrive at our following specifications. Specifications for new is exactly the same as one trip protocols. Again now simply use these more rich dependency session protocols for the protocols.
 The specification percent is also quite similar, we can only send over channels that in fact, sending channels or sending permissions. To sign, we still have to go up the ownership not specifying the protocol of the session protocol. We can always send values. According to the protocol. And the result is a channel can you ration. Which we then operate over according to our tail. Finally, the biggest difference is this T here. Which is the determinant sensation chosen by the user for the session winder, the particle binder. We can always receive on the receiving permissions. As for this post condition. If we enfold receiving protocol we can see that these correspond exactly. Now this might not seem entirely obvious but at least it does feel canonical. And the foundation for this canonicity be is that we have these one-shot specifications in particular the cruxes that are devastation protocols rely on the higher-order invariance of Iris. To make sense of this, recall the following definitions first of the channel and point permission and ascending protocol. And then the following unfolding in which we first unfolded channel in the channels. That's revealing the underlying invariant. Then unfold ascending protocol reviewing the underlying a channel permission. And then we finally see these invariance inside the invariance which is only made possible by the higher-order nature of Iris. Once again these are readily supported so we are in the clear. Once again, we wrap up this layer and continue with the third and final  layer of imperative channels. The problem at hand is that working with functional channels is quite inconvenient as we keep having to pass on the channel continuation. And said we work around something more imperative where we can just work on the same channel and point. We can achieve this quite medially by simply ratifying each and point and with a reference and then updating the reference in accordance to the current channel and you ration of the end point.
 Within this we can finally write programmes such as the 1% that is in the introduction. The crux of obtaining the specifications of these protocols, is the following channel and point ownership. Which simply wraps the original channel permission with the reference corresponding to the imperative implementation.
 We can then get the following specifications which is a slide --slight variation of the function specific Asians were we simply update the channel and points instead of passing on this channel continuation. Now note that these specifications are exactly the actual specifications of the original Actris paper. That is the goal. An alley specifications can quite easily be proven with trivial reference reasoning. As for the crescendo of this talk. I finally prove the example of the introduction. By taking exactly the port of call that we specified in the introduction which you have now seen fully derived throughout this so far, 20-minute talk. We can affect also prove our programme using the presented specifications and using new chant to get the separate channel ownership. And then following the rest of the protocol. By sending over this reference ownership. To wrap up, I will just ruefully cover some of the additional features of this many Actris features. We have the recursive protocols and we also have variance because which we for instance can choose to receive integers instead of actual numbers. And we have a notion of challenge de-allocation of some traditional approaches in which we have symmetric and asymmetric coronation between the two endpoints. And a new variation in which the final will also initiate the channel. Finally, I have not been able to touch too much on this nice conversation. If you read the paper you might notice the small gears, where you can click them and they will take you immediately to the corresponding Coq mechanization.
 To conclude I just want to briefly compare this work with the existing Actris work. We now arrive that many Actris that supports a many of different features. And affect this version Actris of supersedes the original version of Actris the 1.0 even without employing any they heavy cannons. Heavy machinery. However it should be notice that this heavy machinery was later put to work in the subsequent work, Actris 2.0 and the language generic approach to banning separation profiles and which was Actris the co-3. And that it which was put to work in the issue booted setting and some other work that was presented yesterday in the ICFP. Which you may check out if you are more curious.
 Finally to conclude it seems there is a very strong, nice course - between sessions and the higher order separation logic. We have achieved this mini Actris programmes. A separation logic proof Pro for verified message passing. And we do this with three layers, one-shot, functional and imperative, simple soundness proof with nested invariance. Abundance of potable features, and mechanized in less than 1000 lines of Coq code. And now outstanding question is whether this simple enough to incorporate in separation logic courses and I mean I would always already bet that something very similar already exists throughout the world. And based on what you have seen today this session channel is hopefully seen within arms reach.
 With that all I have left to say is thank you and then I will recursively take your questions according to the protocol. Thanks. 
>> ANDREW HIRSCH: We should have plenty of time for questions. 
>> Hello Simon Fowler University of Glasgow, I've got to if I may? So the first one, first I want to say lovely work is really nice and I really loved your talk. 
>> JONAS KASTBERG HINRICHSEN: Thank you. 
>> There was some work in 2017 by Alchester-- about a similar encoding to kobayashi the and data work in the multiparty sitting. As wondering whether you think that your approach will still so that? 
>> JONAS KASTBERG HINRICHSEN: I'm not too familiar with that work. Hopefully at least the implementation solution should scale. But one album that we are facing currently in Actris the line of work is that the multiparty session types in this era very difficult in the presence of the dependent binders. So at least the conjecture is that the stuff might be possible but will possibly have additional work to be figured out. 
>> Okay thank you. And the second question was, just really on the talk I was kind of uneasy about the spinning implementation of the one-shot channels. I was just wondering whether that is problematic in practise there and whether you know, if so if there's any better ways of doing it? 
>> JONAS KASTBERG HINRICHSEN: Right, so for what it is worth, like in the iris setting we usually mostly consider partial correctness. So non terminating programmes are fine. Which is why we allow ourselves to be spinning. We do not have any proof in this work, of deadlock freedom and stuff like this. So we mostly just hope that people write the proper programmes. However, we have made some subsequent work on this. Where we take a similar approach to this actually obtain DevOps freedom which we instead have a nonmoving variation.
>> AUDIENCE:   Brilliant, Inc. You ever so much. 
>> ANDREW HIRSCH: All right are there any other questions? All right if not let's say thank you to Jonas again. 
>> JONAS KASTBERG HINRICHSEN: It's always fun when you cannot hear the clapping. At least I expect there is some clapping. All right, thank you.

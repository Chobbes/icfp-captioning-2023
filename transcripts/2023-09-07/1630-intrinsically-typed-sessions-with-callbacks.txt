
>>  A really quick recap, the session type is one that describes the communication channel. And in the simplest essential form it is the sequence with the direction of messages. So S the is a typical syntax that is used. So the session tab may either be you want to send some T and continue with S or you want to receive some value of type T and continue with S and that means that you have to close the centre. On the bottom you see the samples here. This will be a server for the union area function that receives an integer argument and then it sends up integer response and then it closes the connection. And another concept that is often used I'm not sure I will get to this Montauk. So type of the client on the other side that would be cut you would get that by just reversing the direction of the communication, so the client has to receive an integer, sorry send an integer and then received a response and then both agreed to close the connection. A tip-- global typical API for session types transforms the types for talent. So for sending you take the value that you want to send and is paired with a channel that is ready to send something. And then continues as S an active sending turns that pair into just the continuation session the rest of the communication channel. Which runs the rest of the protocol. Similarly receiving on the channel that is ready to receive. The returns, the value received, the channel where you can do the rest of the communication. In this case close the different ways of doing that. And just saying close, consumes the channel entirely. And reentering something in this case a unit value. As you may have gleamed from the connectives I'm using. The session types are linear and here brought you a little piece of code. For such a unitary function server. And here you can see the channel of types of zero, it starts at unary the function or the protocol, after receiving argument the remaining channel is typed at well send an integer and then end and after sending the only thing that is left to do on that channel is that you can just close it and that is what the code essentially does. And is crucial that the session types are linear because otherwise if I were able to use CO the value several times that I would just brake the protocol. So not after I've done the first received, then I have to send something on the channel and I can't receive something again because the client would expect something different here. So what am I going to show you in this paper? Actually brief films in the stock. Essentially possible to come up with a safe session type API without using any that linear type stuff. This linear type stuff has hindered adoption of the session typing. Because most host linkages, until the app and of rest I guess, didn't have any notion of linear types. And linear Haskell I have to say. Didn't have any kind of linear types. And so you are always a little bit at its. And then actually this linearity period I do actually adhere to do that. And hear them tell you can do it and you can be type safe protocols safe without using any kind of linear times. And it turns out a modicum of index types or say GDT's is sufficient to do that. And the secret sauce to do that is that any functional programmer should know and love namely callbacks. First-class functions. They are the heart of the functional programming and you store them in the data structure. So exactly like the first ideas of functional programming. So how do we come there? Well, we still, as usual, very clever guys you Ferrera and Stu, they came up with this idea of embedding multiparty session types which is way more complex than we will discuss today. Into a typescript. And they developed a type safe typescript into embedding session types which did not require any linearity because here it is probably too small to read so provides developers with typescript APIs generated from a communication porthole and this generated API complements the event driven style of programming that you have in that web programming. This is too small. What exactly do they propose and that paper? They said we want to use a callback style API call for clients and service. They said -- every time you have a JavaScript or typescript API almost all of them are like that. So they can produce these typescript APIs in a callback style to statistically guarantee channel. Linearity and when I wrap this up, typescript doesn't have linear types and somehow they do that. So how do they do that? They translate their protocol into the endpoint finite state machines. And then and there callback the API styles type signatures of callbacks are generated in these transitions for these finite state machines. Now I don't expect you to read the rest of that. So just have a look. This is what the generated stuff looks like. And you can see the type with the telling name as 40, and the interface S thirty eight as 30 underlying query blah blah, blah and they show up sparingly in the code that you have to write. So what it would show up for me, and look like if we were using a functional language in a more serious way. And it turns out that you can do that and there is no code generation required whatsoever. Which means that there is no interfaces, there is no funny generated names and interfaces that you may have to remember or that you are typing Immerman has to remember. Instead what you have to do is we are going to do a similar road than even monads or even free monads we are going to have a data structure command. And this command a data structure will be the container for a lot of callbacks. And then what we have to do is we just have to interpret this data structure. And while I believe we can pull us up in Haskell, when I was writing the paper I was too tired to do that. So I used a type language. I thought I would get more trajectory. Anyway the same thing you saw a couple slides back with the linear style and commands topic and essentially what we do is this is the specification of the negation server. And it is a command with this session type of a unary function more or less. And it says receive something and that is the callback for receiving and the callback for sending something and that is the callback for close. And then what we have to do actually the callbacks have to do, we can look up in the paper by Mu and others and then prompting the payload type as a return type. So that the return value can be sent to the runtime. By the runtime. Receiving actions corresponds to callbacks taking the payload type as an argument type. So that the runtime invokes the callback with the receive value. And I will show you in a couple of minutes, well actually in a minute what that looks like here. Here, let me just give you a brief one here. Receive now, we expect the value of the payload type to come and. So that value gets bounced to ask. Here now the letter a value is the application state. You somehow need to put that. And that is the new allocation state of the upcoming application state. Similarly, for sending. For sending we are obtaining the efficacy and we need to output the value, somehow we need to extract the value that we want to send from the application state. So that is with the callback and send is doing. In the typescript implementation be a little bit imperative. Of the application state is implicit. And so now you don't have these extra arguments and return values laying around. They are just encapsulated in the generated library code. All right how do we encode session types so that should not be much of a surprise. So we are more or less translating these grammars into Agda, I don't see questioning faces so I don't need to say much about it. Okay so let's look at the commands, work on an application state A like I just told you. So command type has to be parameterized over A. And then it takes the session type as the index and essentially closes. Well the close just the index and and it doesn't do anything here. For the sending we can see here, this is the sentence but I stole from the paper. We for the sand, we have a callback that elicits the value of the payload type T from application state and it can also transform the application state. And then it takes the continuation. Right? I mean the next command. Taken together that is the command at this type send a T and then S. Of and then forward the receiving actions corresponding to callbacks, taking the payload type. Well we are taking the payload type and transforming the applications state so that we can somehow integrate that and then that gives us a command. And the receiver of T and then S type. And then you need well the T are the syntax of the payload type. So you somehow need to translate that into the actor and that's just implantation detail. So more thing that we just mentioned previous slide, we have someone to execute this. So we build a command data structure. We need a interpreter for that data structure. The interpreter is really simple. You know that if you stay close, you close. If it is sent, well it just extracts things from the state and the right way. And it sends, receive, receive so that's it. And that is some proof application behind the because that's like the only place in the whole system. I mean if you use, if you build your code on top of that, that will be library. That would be some sort of trusted computing base. And that is the only place in a system where you could brake correct linear handling of a channel. And close here you have this channel as an argument and you have to ensure that the channel is really handled linearly and nobody messes around with it. And that the commands are kind of interpreted faithfully. That is of course the proof of application. Right now this is done by inspection. I believe more can be done about that. I have some ideas but I'm hoping that some clever person in the audience may be comes up with a clever way of getting rid of this proof obligation. All right, so that was kind of phrase turning point. And then I thought okay this has to brake. As soon as I have, as I put in the more features of the session type. Somehow, there is someplace where this is going to brake. It turns out know, so far the features that I checked off just work. So for example you have selection and choice which is kind of branching in a protocol. So you have two of the operators in the traditional session types, mainly you have internal choice where you can have your code choose between different continuations. Indexed by some label earlier. Or you have external choice for your code and handle different continuation. So you receive an indication, a label that tells you this is the continuation that the other end of the channel has used. And then there is, the simple matter of including that so we have the finite set of labels so that should be included as a finite set. In the Agda code and then you can more or less write those predicates, those types. So this is one possible, I should say the most convenient possible interpretation of this, these session type constructs into Agda code. Essentially here you model this indexing by letter L by function from this infinite aspect finite set into a session types. Other encodings are possible but they for strict positivity of the types so you actually really like them that much. So what do the commands look like? The an choice if you don't look careful enough they look extremely similar. But the single bracket. So for the choice that is interpreting the external choice, there is the first argument is a function that takes a label and delivers the command, corresponding to that label, processing that particular externally chosen continuation. And for the selection you do this choice by yourself. And then you just continue with the continuation that you choose. So here you have two arguments and for the choice you just have a function that handles the incoming label and then goes out. Rating code again is straightforward and here is a nice example where you see that you can use the host language. To advantage to write really modular code. It gets really readable, so you can name your session types, so that is all any binary, unary binary protocol. Then you can form the arithmetic server, well the X approximation of the arithmetic server that is kind of the standard example. Just as the external choice between the binary and unary. And the command data structure is indexed by the session type, once you have specified the session type, the programmes almost write them by themselves. Because you have this interactive way of constructing your programme. And so you say oh, this command you would say it is a command of this type errors scheme and you put question mark at the point where you have the choice. Whether is not other possibility of putting a choice that. Because the type of errors tells you this is the choice. There is nothing else you can do. And once you get here it is obvious from the protocol definition, this must be a lambda and it just has these two cases. It is no other possibility. And here or here I can choose any command that has the suitable session type. But I show you it is the HP it's not much different from that. In the interest of time, will gloss over that a little bit. Next up is of course recursion. Of course we only look at the finite types. That is the place where things got a little bit more involved. So you have -- a tape and the type variables and you call them and just usually. Yes let's not get much carried way. So you get the commands and you get the looping command that takes the command for the better body of the loop and then the consideration and you have the continue in the continue essentially works like a brake statement that you may know from Java. In Java you can also brake to a particular label. And that will also leave a arbitrary nesting of loops and similar that's how this continue works if you have several loops you can jump out of any nesting level of the loops as you might expect. So one thing that is interesting, maybe. This loop, command, from the command you can see this is the command for the loop body, so for all iterations of the loop body. This is probably fine for a server. But if you write client code against such a recursive type, it might be a bit annoying to do so. Okay so fortunately, you run into this issue as soon as you try to write any sort of example. So there is additional client command which is called on will and it takes the command for one iteration of the loop. And then you are back at the head of the loop and can then specify another command. So this means that you can kind of unroll one iteration after another with this unroll command. And this also right kind of finite client code. That type text against a recursive session type. Well, that is what I just said. So as I said, this gets a little bit more tricky in implementing things. And so the interpreter has to maintain a continuation which essentially the loop commands and as you see here I don't have time to go into that. So there's a whole page of the paper dedicated to that. So the command stack has an interesting type let's say. And that gives rise to some interesting complications. And then as soon as you have loops, you also run into the termination and Agda code doesn't like you to have non-terminating code. And then it runs to the first continuation and then it issues something you could call it a resumption. It is a continuation paired up with the current application state. And then you can kind of limit the places where you have to use pragmas to convince actor -- this is just the place were just a small loop where you on full that resumption and call it the interpreter. All right, yes. And then there is some further variations that I tried. So that you can find them in the paper. So seven years back about. Vasco and I we propose something called context recession types. So here this traditional session types are all tail recursive. So you always have to have the form to do something with the value of the type and then continue with S and then do something to receive something and then S and in context recession types we have some symmetric condemnation operator and then you can come or that works and you can include that as well. And the next question of course, what about having more than one channel so far? I only showed you types and code dealt with one channel. That gives another level of complexity that you can do that as well. And at that point you get close and you can run into similar issues as with the multiparty session types. So the paper give some more information about that. So this gets a bit hairy.
 Another thing that you can do is so, the callback functions that we have seen, I told you, that all kind of look at the application state. They modify the application state. So it seems, it seems quite similar to what you would do in a state monarch. So you would say oh there is this application state monad and all I'm doing is feeding and stuff and pulling stuff out of this application state monad. You can use this monadic interface to callbacks and probably that's the way you want to go because maybe you want something, your application programmes, to do something more interesting than just adding two numbers. Maybe it wants to add some I/O or something and then you would have to have a monadic programme. It is also something that is described in the paper. There is some technical issue right now with that. So it would be letting you pull it through all the way. But you can see in the paper. And so I show you that there's a callback style enables you to safely embed a session types in a language without linear types really. The fee use such a command data structure with the index types, that is completely avoiding any cogeneration issues. And now future work as I mentioned is already there before like proof obligations on these interpreters. I mean all interpreters are very similar to the one that I've shown you on the first light. They just get more cases, they don't get significantly more problematic. And with that I can only encourage you to check out the artifact and have a look at the paper. Thank you for your attention. 
>> ANDREW HIRSCH: Thank you very much we have plenty of time for questions. 
>> Hello Simon Fowler University of Glasgow, thank you for a nice talk. So I agree that the encoding seems very, very nice for the single channel pays. So you acknowledge that it is slightly more complicated when you have multiple channels. So I was wondering how the complexity of multichannel compares to other actor encodings for example left over typing? 
>> PETER THIEMANN: I did not understand the last sentence. 
>> , sorry I was wondering how your multimode channel version compares with other implementations and actor, where we have explicit linear references, more GV style allowing multiple channels? 
>> PETER THIEMANN: Okay as far as I know the typical style that you would do is you have some kind of linear state monad that encapsulates like a vector of channels. This is exactly what the interpreter tells you. So the underlying implementation is probably you do, and on the user level it you went into similar issues with causality as you run in with party session, multiparty session types. And probably you would want some extra layer that makes it more convenient. Because otherwise you would have to kind of repeat things too many times or something. I don't have much practically experience with that. I mean, with the multiparty's stuff, I actually managed to get the compiler to work. It did work for all the artifact people, I apologise for that. But you can actually try it out and run the code with this multichannel and if you have a nice application, let me know about that. 
>>  Thank you very much. 
>> Hello, Papua Dominquez from -- I was wondering this approach seems to giving a solution for Agda code, what are we doing in Haskell we also have linear types? Should we use the linear types in the traditional weight or should we try something like this instead? 
>> PETER THIEMANN: That is an interesting question. I don't really have a good recommendation for you I guess. I would say that even though the you have the linear types in Haskell now, doesn't update the use of monads. For encapsulating state. The nice thing about this approach is that you actually have your action or your command as a datatype which you can manipulate independently without caring for any linearity issues. If you need that or if you want that extra flexibility. I would think that would be more convenient. Yes. It is I guess all I can offer you. 
>> Thank you. 
>> Thank you for a nice talk Peter, this is Sam Lindley, University of Edinburgh. Of to answer that question take a look at a a by myself and Garrett Morris, I suppose in 2016 on embedding session types in Haskell. I wondered if given that your independent lead time programming language, have you tried to encode dependent setting types? 
>> PETER THIEMANN: I haven't but given that the language is the underlying host language is dependent, it should not be an issue. Yes, that is probably easy to try out. 
>> Thank you. 
>> Hello Mike Spurber, Active Group and probably stupid question but I mean your construction look similar to sort of the free monad pattern, and the exception with that command is usually returned by the continuation as opposed to it could be a pattern generalized to fit somewhere in the hierarchy 'tween the functor selective and give that cause and things like that? 
>> PETER THIEMANN: Actually when I was preparing the talk I was wondering something like that. I guess is current structure and it will be more object because you have that this variation of multiplicative which escapes me that Simon Marlowe and others where you have the finite choices inside the applicative. Selective right, but that could be related but it only occurred to me in the last two days that it could be something like that. But what I would certainly like to explore is improving this interpreter, I was thinking that was also thing about choreographies Haskell were, they also use free monad for that. So instead of having the encoding directly in the interpreter got you could also kind of outsource this by an -- interposing a free monad and then you need some interpretation of the free monad and then you would still have the allegation of that is the right thing. 
>>  Okay let's maybe take a less question and then have a remote talk. 
>> Hi, I had a question so the original message that you wanted to bring session types to cut you know, lots of languages you don't have linear types. Most of them are not pure. So you brake your guarantee when you have side effects? 
>> PETER THIEMANN: So the question is do I purity in that? 
>> So in Agda code in a peer context, if your host language is not a got does it brake all of the guarantee regarding the psuedo the linearity let's call it? 
>> PETER THIEMANN: I guess you could brake purity and this TCB in this interpreter which is why there is a proof obligation. I mean this interpreter runs on top of the Eio monad and even in the actor in the-- monad and what you call it. 
>> While I'm talking about the callbacks. 
>> PETER THIEMANN: Well but now they are peer, what I was imagining an extension is that you make it an attic and may be given access to some limited version of the I/O. 
>> ANDREW HIRSCH: Okay I think something we are ready for the next talk. Okay thank you again Peter.

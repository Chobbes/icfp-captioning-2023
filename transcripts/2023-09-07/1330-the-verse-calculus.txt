                >>PETER THIEMANN: Simon, tell us about The Verse Calculus: A Core Calculus for Deterministic Functional Logic Programming. 
                >> SIMON PEYTON JONES: Okay this is great. One of the nice things about working for games company is you to have cool pictures on your title slide. And another nice thing is that when someone ask you what you doing, you explain instead of saying oh, I need another drink. They say that sounds interesting. And a 10-year-old boy starts sidling up. This is a games, present at a programming languages which is conference? It's because this is a talk about verse, which is a programming language for the measure. I have to give you a 30 second sketch of what the Metaverse is about. This man here, and a photo, this is Tim, the regional implement your of the unreal engine and Chief Executive and founder of Epic Games so the plan for the meta verse which has been incidentally talking about much longer than anybody else. And about the Metaverse is that you know an immersive three D real-time space in which people can interact socially and indeed business I think. And there's a strong emphasis on it being a open economy and not corporate overlord thing. And kind of ground rules for any creation plan for more lots of people can grow and flourish and have their being indeed independently maybe making money. And that places quite strong technical requirements on. Get the got to be a place where lots of separate people and build, and they can act together now nicely. And that is the emphasis on open standards. And that is a slogan for the Metaverse. Tim is going to be doing some asking me about that later this afternoon. So can ask normal that. Then in that setting, why do you need a new language? While objectively of course we need a new language we could use Fortran right, there could be some reasons why we might want to have a new language right. It could be a bit scale running code written by thousands of an thousands of people that we've never met. Supporting millions of billions of users. And has to support very good transactions. That's way we can coordinate lots and lots of independent people interacting and a shared 3D environment. And you've got very strong and drop guarantees over time so that you stuff doesn't just top suddenly working. Tim is Y the images for verse. And is going to be usable for people early learning to programming to expert developers. But could be long-lasting and accessible. I think anyway, I hope I'm not rest -- misrepresenting you Tim here, but that sort of the heart is this a chance to think of fresh and enterprise of programming. And we have glowing eyes. If you like. I'm just going to give you a little sketch of what the versus doing about the technical innovations we have made to make it happen. But before we do, here's the plan of what versus doing. So ship verse, it is version of verse should be now that you can get in and download it just and that is my job here and the other people on this team, and this is elaborating the full glory of what Tim has a mind. And we hope to meet in a stratospheric so we have launch the plane into the air. While it is kind of still designing the wings were it is kind of exciting, kind of scary, is a games company.
                 So Tim has been thinking about verse for a long time, probably for two decades. So you have had a lot of a lot of stuff going on in his head. And the job of you know my job, Leonard job and other people job. There is an amazing team most of them are more clever than me. We are sitting there trying to suck the verse out of Tim's head and understand what is. And we have two hours a week with him on the phone and we suck and suck, we and what do we get? A huge pile of spaghetti. So our first task is to make sense of this paper and the first attempt to give a articulate core computational model verse in a way that would be  understandable to the PL committee. So here's what the view from the 1000 feet of what versus about. So is a functional logic that is functional programming and our love here is kind of a niche within programming at large, functional logic programming is an I will tell you about what functional logic programming is. And is a do clarity of language in that the sense that a variable still stands for just a value, it does not stand for a cell whose value can be mutated over time. I take it in the defining characteristic of the cord of liquids. It is very declarative. It is lenient not strict. Selenium means everything gets evaluated in the end but not necessarily ordered. It has a rather unusual strategy type -- static type that I'm not going to have time to tell you about and has an effect if a system and I'm not going to the time to tell you about twice. I'm just going to focus on the core functional logic parks in the stock. I will focus on the functional logic part. I do want to assume that you all know what functional logic programming is. Because I've heard about it and read papers about over the years. But until I started at. I hadn't really got that visceral sense. Some going to attempt to an the next five minutes to do a sort of immediate download of functional logic in your heads. Here are two defining load characteristics. One is the existentials and equations. And the other is choice. And you might imagine that source verse is a big language with plenty of syntactic sugar. We will put that down into a court calculus that is the main topic of the paper. So the paper is informal about source verse and precise about core verse or the verse calculus in the talk I'm going to be informal about core verse and I'm not going to say anything about source verse. Just going to dial it back a bit it is a talk. So the picture you will see is this core verse thing.
                 Okay Existentials so and logical variables what are we going to do? If you say well Haskell let's say X equals you say let ask equal letter E something. And so does two things. A brings letter X Interscope and it gives it a value. Maybe not a value that's computed medially. But you say right then we give value of X will be right? Here it is, inverse you bring ask-- X Interscope with this Existentials guy and constraints X is value within equation or maybe any equations. You see the point is two pieces are separated. And they might as well not be separated. But the functional logic programming you can separate them a lot more. So here are some other examples. I have brought X Y and's Interscope and what I've said is that acts as a pair. And then separately I've constrained letter Y and separately have constrained letter's. And overhear I don't mean to bring them all Interscope it wants. Here are brought this Y into scope, just this one here. For us, even though letter Y isn't a scope yet. And what is happening over here, here it is really just like a let for F. It is this lambda. If I'm calling F, passing letter X, oh this as yet you know I haven't given X a value. But look inside letter F, give X value, but these  Existentials can be passed around and partially constrain the values of Existentials the values. So far so good? Okay. So how will we execute programmes like this?
                 Well as you know, may guess that 75 % of you are already thinking oh, we're just trying to Existentials do is just a unification verbal. And the execution is going to mean unifying. But slightly more abject way to think of it is we are just try to find a solution, find values for the X essential variables that satisfy the equations. So quite declarative. Just find the values that certify the equations. So here in a little programme here, I've written down the equations for XYZ. And the solution is that X is and the pair 2, three, Y is two. And letter's is three. And so I've stated any execution mechanism is likely to be incomplete. In fact certain to be incomplete. So I could write exist X X equals execute that for programme because well you know it does have the two solutions. And the execution mechanism unlikely to be able to solve. So necessarily incomplete and that's okay. You have aspirational semantics and then we are going to try to constrain a bit. Okay so that is Existentials an unification.
                 And then the second component was choice remember? Once you've got these equations, it might be that there is no solutions. No solutions. All right? Or there might be many solutions, maybe? All right. So that means if at least there is a 9 or one that expression might simply fail. It is not giving a value it all. It is not hard to an functional logic language is. That is not specific to, by verse by the way. The ideas to generalize expression that they can yield 0, one or many, and it says that X is either equal to ask either 3 or four. So this whole extension it doesn't bind a peer of 34 it doesn't work it like a comprehension and Haskell. You can imagine it finding extra three and then buying the extra numeral four and then it returns to the whole expression returns numeral 4 or five. All right so the idea is an expression of yield 0. And one or many rules. And really the core idea is that the slightly more unusual versus less you reify these choices back into the data structure. So this thing, the structure here, it takes the expression inside, and takes all of the values that it can return. And it turns them into an array or to pull, they are the same just as they were in typescript in Anders talk, yesterday, the day before yesterday. So what does that tell us? This idea of encapsulating choice. So that you can get all of the values returned by an expression, that is a little unusual in the functional logic area. You to be functional logic languages. This choices at the top level. And you execute the programme to get sets and bindings. And this little prologue, you run the binding and it says X, three and like before or another possible solution or another possible solution. So being able to reify the results into a data destruction is foundational he inverse. But slightly, more sort of an extra and most functional logical images. But it forces us to do some things right? It matters where you get the array 2, 3, four or the array 2, 4, three. So the order of the results returned by choice matters. The best way to think about is the verse X person that returns 0 or more values but a sequence of zeros or more is not a set of that. Or back. Okay good. That is why they determine a stick in a very title of the people. Because this choice has a kind of pervasive effect on the language. It makes it rather different to say Curry. Okay how are we doing? Okay you can see the superset of the lambda Caucus, and the land is down here, their normal forms and had normal forms of values, values incidentally include just variables and expression can be a value. So you can see that here's Existentials and it is a small language, and this language is untied by the way. And how do we get the whole semantics for this language? Plan a is you look at the programme you try to figure it out and you say let's asked him. Okay will this doesn't scale totally well so you really need Plan B. And so this paper is really about plan B. So there's various ways of getting the semantics of the programming language in the ICFP space, one is operational semantics. Right? Typically you have something like the heap and a stack and expression or some code. And you have transition rules here, is looking from peters paper. The heap expression stack transitions to a new heap expression, that small step operational semantics, progress and preservation and all that stuff. Which is great but if it is a bit low-level for programmers, you are trying to explain to a programme or what their programme is doing and is not great. Good for compiler writers. Another thing is you can do is write denotational semantics and now it is great because it is to directly reflecting what I said. That meaning of the expression and a sequence of values. So you might say here your meeting function takes an environment that binds the three variables to a sequence of values of W star. And the constant you get unit sequence for fail and you get empty sequence for choice of course to get the union of concentration here. And sequences. But equality, this is great actually. Turns into intersection. So this is a nice feeling that old these are fitting together, the choice turns into Union, E quality turns into intersection and then we ran into the sand. What do we do with Existentials? So because it's not part of the paper, there's a little appendix that sketch is what we are doing and Stephanie Warnick is busy formalizing a denotational semantics for verse and Coq. But I don't understand any of that, I'm not going to tell you about that today. We are going to do is rewrite semantics. So what we say is extent Haskell to programmers. So if you're Haskell programme is the definition foo of an imagine rewriting it in different ways. Imagine you valuing the three + 2 to five and then we might and line food and then five times five + one. And then we might evaluate the five + five and then we each actually there's a lot of exclusion past. So the source rewrite and you apply them anywhere. And they all lead to the same answer. That is very important, that is called confluence. Right and it is very good to explain what a programme means to a programmer. Just say keep applying these rules and eventually you will get to the answer. It is very good for the compiler writers as well because they can write these rules sort of optimization. So good, maybe we can try to describe the semantics of the rewrite books. Well, then we, I am a bit struggling with how are we going to express the semantics and unification and so forth using rewrite rules. That seems a little bit tricky. And then we stand on a so shoulders of giants. And that is inspirational paper by Zina, Matisse lysing, John W, every-- and more listed, every school should read this paper. It's great stuff and to express the ordinary lambda captures you can easily express call by name and call by value, but not really its first call by name. By adding let to the language they are able to express directly call by name and having left the calculus. So there's that little quote from the paper. The idea is to represent a reference to the actual parameter in a function graph that is kind of messed up pointers by a letdown identifier. There's a translation to ordinary language. And so this a lot, you have X instead of having a pointer to numeral two. You know to a graph node, and I just let mind it, so let findings are modelling in the structure of the term a modelling a heap right and then you see in the implementation. So let's see you got an action. Here is a little verse turn and it's got sort of equations and in fact these equations are already very sort of like heap bindings. And you have this X and this paired with two, Y. And substitute that and now you have two Y. And you have that so now what? Let's take it apart and it has's equals two the first components and then letter Y equals three. And that is the unification step. And then some more substitution. Finally get to the 2, three at the end with a bunch of bindings hearing that we no longer need to so we can garbage collect them and away you go. Essentially we executed a vacation algorithm just by applying rewrite laws.
                 So the paper has a whole bunch of rewrite laws as you can see. I will show you very quickly some of them. So here is, oops, here is some unification rules, one equals constant two, if these two confluence are equal I can just a lessee quality way. Because the tuple we can take it apart we so that actually happening. I will ignore that for now. And all that is just a reminder of the syntax. But very excitingly, here's a substitution rule. So when I have, oh look at the binding for Y, otherwise so the variable equals value, if one of the qualities of the form variable equals value, then you can replace the currencies in the variable by the value and then the paper at least in both directions. Both to the left and there is went to the left and then to the right. And so hence it slightly funny notation. And then X equals to be in the context, X you consented to both a good substitute B four X both and X to contents-- context and in the bit that follows after the semicolon. So that's a bit like what happens in unification when you update a unification variable. Except that's just the rewrite. So those are kind of the key rewrite rules. Then ten of course there's others that are more familiar. And then there is more primitive operations like addition. And it mentioned the Boolean's, Boolean type in verse because there is like icon, if K- 1 is not bigger than K2 we simply fail. The fail is not bad. Feeling is like nothing in Haskell it just means you return no results. Okay this is the beta reduction rule, how does it work? Well, it just going to say it actually this is a bit like a X equals letter V and letter E. It's very nice although substitution isn't part of beta. It was part of this, it was done by this substitution rule. Okay enough of that.
                 Chooses interesting if you read papers about calculus involving choose. You will see a rule like this. And inverse inherence this complete we. In the choice some contacts got some term will choice in the middle. You can copy the context and push it into both branches. That is sort of forking the context. So a very simple, adjustable Kate the context. CX in both branches. And I have to say that this is not, the thing in the paper, this is not completely satisfactory. The choice will have an additional SX things as described now. And the truth in advertising, the progress is being made. Okay. So here are all the rules by the way. And I put them up here. So really the idea that there is let more rules and the lambda calculus. There is a bunch of, did I talk about the administrative reductions? Oh no, I did not. These ones, there is quite a few normalization rules, and very like the ones in the other people are that move it out of the way. This one that says to the left of the colon and another semi colon. And so it is quite a bit of real so seating rules that exactly like what happens at the reallocating and you need those just make this rewrite work. But they don't get the way. So we want to prove this confluence. And at last it isn't, for various reasons, it is called the even, even odd problem. It is sketching the problem and it means that the terms can look syntactically different but they are semantically identical. In solution one is just too restrictive a little sub language that doesn't have a problem and that is what we in solution one is just too restrictive a little sub language that doesn't have a problem and that is what we do in the paper. But we are working hard to Guy Steele is working hard on the proof of skew confluence which is a slightly weaker property, perfectly adequate for purposes which we think is whole. So there is lots more to say, not the paper but mutable state transaction state transactions and I have to show you this slide, I do not have time to tell you about it. So I will leave you with my takeaways. And what I actually try to do is this crazy stuff. While the airplane is taking off, we are busy designing these wings and the wings are pretty interesting and fun. It's been on a wild ride. The last thing to say is versus an open project, the verse compiler as we produce it will be an open source thing. And you can all use and we hope to have an open conversation with you. And publishing this paper is sort of the first step in that open conversation. And just to say, 5:45 PM today right here in this room Tim will be here for the ask anything. Come back and you can ask him some broader questions about the Epic in the verse and so forth. Thank you. 
                >>PETER THIEMANN: A few moments for questions? Jeremy? 
>> JEREMY: Thank you one of the work for he died last year was a booking algorithm design with Haskell that I helped him live. Which was doing lots of optimization problems in almost Haskell. We found we need a little bit of non-determination so there was a little sad. Outside of our Haskell so minimizing them takes a collection of elements and optimization function. And returns anyone of the optimal elements under the optimization function. Should be and mean if we be doing this now, should we have done it in using verse rather than-- 
                >> SIMON PEYTON JONES: You haven't given me enough to answer your question. I just don't know. 
>> The equation of reasoning with the first programmes? 
                >> SIMON PEYTON JONES: The equation reasoning are the reason like those rules. You can use all of these rules to make equation rewrites of birth programmes. --both programmes. Using operational semantics you know, have fun. 
>> Nick Ryu, University Pennsylvania, great talk, at the beginning you give us a slide about the grand vision of verse and all the scalable extensible transaction will language and then we honed in on the functional logic programming and choice. And unification. Can you connect the two for us all of it, how does this functional logic programming take you to this sort of grand world and what is a doing for the programme are and why is it the feature that you want to using your leg which? 
                >> SIMON PEYTON JONES: You can, up on this, the functional logic have to do more about the bullet on the last side get the chance to look again at the entire enterprise a programming. I don't think that we need functional logic programming in order to get transactional things or in order to make it compatible. So there is a lot going on at once here. If you like. I think this is another and a good question to ask Tim this afternoon. 
>> Thank you. 
>> Hello Todd University of-- and the reference-- the logic variables and functions, can you get landings on the expression recursion? 
                >> SIMON PEYTON JONES: You said the logic were was a bit like reference cells. 
>>  Yes so when you have reference cells for functions. The entire landing is not a recursion if you don't pull it in. So the last slide that you try to put rollout, recursive functions to get some results. Are you sure that you don't get landings not Sky 
                >> SIMON PEYTON JONES: You sure you don't get what? Landings not. I'm not sure exactly what landings not says. I guess I'm not sure. For unification verbals or maybe a little bit like the reference cells. But reference cells are changing their values over time. In the unification variables do not. They do note one value that we do not know yet. That is a very big difference. 
>>  You get to know more but as time goes on. 
                >> SIMON PEYTON JONES: Yes you get to know more of it but really I  [ Overlapping Speakers ] I think there is a problem you should really think so much about that you should think about the value that it has. And implementation. 
>> That's take it off-line. 
                >> SIMON PEYTON JONES: I hope at least the rewrite rules in the paper make precise, walk the semantics of verse and maybe that will answer your question. But maybe you should show me landing and let's say I've swept over and what happens if you take inequality between two functions right? Do we get into higher order function unification? No we say we are just stuck there. 
>> Thank you. 
                >> SIMON PEYTON JONES: There is no higher order unification. 
                >>PETER THIEMANN: Hello the next speaker is getting set up. 
>> Hello Roger Patel --University. Please excuse me if this answered in the paper, I notice on your normalization that you have the classic constraint of your-- free variable flowing expressing-- 
                >> SIMON PEYTON JONES: Sorry I'm having pausing problems. I'm going to get closer to you. 
>> So do you do the rewrite or do you dutiful capture of avoid names. And just like in the rewrite rules for landing campus, would you say you capture the substitution here now? And just like the rewrite rules you just a to avoid capture we are just going to also rename the thing. So just exactly the same as lambda campus. That's all. 
